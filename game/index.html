<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KNOCKOUT! — Retro Boxing</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box
    }

    body {
      background: #0a0a0a;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
      cursor: crosshair
    }

    #wrapper {
      position: relative;
      image-rendering: pixelated
    }

    canvas {
      display: block;
      image-rendering: pixelated;
      border: 4px solid #333;
      box-shadow: 0 0 40px rgba(255, 100, 50, .15), inset 0 0 80px rgba(0, 0, 0, .3)
    }

    #scanlines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(0deg, rgba(0, 0, 0, .08) 0px, rgba(0, 0, 0, .08) 1px, transparent 1px, transparent 3px);
      pointer-events: none;
      border: 4px solid transparent
    }

    #controls {
      color: #555;
      font-size: 7px;
      text-align: center;
      margin-top: 10px;
      line-height: 2.2
    }

    #controls span {
      color: #f85
    }

    /* Party System */
    #party-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    #party-menu {
      background: rgba(10, 5, 20, 0.94);
      border: 2px solid #f85;
      padding: 24px 32px;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      box-shadow: 0 0 40px rgba(255, 100, 50, 0.2);
    }

    #party-menu h3 {
      color: #f85;
      font-family: 'Press Start 2P', monospace;
      font-size: 11px;
      margin-bottom: 4px;
    }

    #party-password {
      font-family: 'Press Start 2P', monospace;
      font-size: 9px;
      padding: 8px 12px;
      background: #1a1020;
      border: 2px solid #555;
      color: #fff;
      text-align: center;
      outline: none;
      width: 220px;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    #party-password:focus {
      border-color: #f85;
    }

    .party-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      padding: 10px 20px;
      border: 2px solid;
      cursor: pointer;
      transition: all 0.15s;
      letter-spacing: 1px;
      width: 220px;
    }

    #btn-make-party {
      background: #2a1a30;
      color: #44dd44;
      border-color: #44dd44;
    }

    #btn-make-party:hover {
      background: #44dd44;
      color: #000;
    }

    #btn-join-party {
      background: #2a1a30;
      color: #44aaff;
      border-color: #44aaff;
    }

    #btn-join-party:hover {
      background: #44aaff;
      color: #000;
    }

    #btn-vs-cpu {
      background: #2a1a30;
      color: #f85;
      border-color: #f85;
    }

    #btn-vs-cpu:hover {
      background: #f85;
      color: #000;
    }

    #party-status {
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      color: #ff4444;
      min-height: 14px;
    }

    #waiting-screen {
      background: rgba(10, 5, 20, 0.95);
      border: 2px solid #f85;
      padding: 32px;
      text-align: center;
    }

    .waiting-text {
      color: #ffdd44;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .waiting-code {
      color: #666;
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      margin-top: 16px;
    }

    #btn-cancel-party {
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      padding: 8px 16px;
      background: #2a1a30;
      color: #ff4444;
      border: 2px solid #ff4444;
      cursor: pointer;
      margin-top: 16px;
    }

    #btn-cancel-party:hover {
      background: #ff4444;
      color: #000;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: 0.3
      }
    }

    #disconnect-msg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 5, 20, 0.95);
      border: 2px solid #ff4444;
      padding: 24px 32px;
      text-align: center;
      z-index: 20;
      display: none;
    }

    .dc-text {
      color: #ff4444;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
    }

    #btn-dc-ok {
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      padding: 8px 16px;
      background: #2a1a30;
      color: #f85;
      border: 2px solid #f85;
      cursor: pointer;
      margin-top: 16px;
    }

    #btn-dc-ok:hover {
      background: #f85;
      color: #000;
    }
  </style>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database-compat.js"></script>
  <script src="firebase-config.js"></script>
</head>

<body>
  <div>
    <div
      style="color:#777; font-size:8px; text-align:center; margin-bottom:8px; letter-spacing:1px; font-family:'Press Start 2P',monospace;">
      Made by Phat Khongthong from GIS AND I AM NOT GOING TO SING IN MATH CLASS AGAIN :)</div>
    <div id="wrapper">
      <canvas id="game" width="640" height="400"></canvas>
      <div id="scanlines"></div>
      <div id="party-overlay">
        <div id="party-menu">
          <h3>⚔ MULTIPLAYER ⚔</h3>
          <input type="text" id="party-password" placeholder="ENTER PASSWORD" maxlength="20" autocomplete="off"
            spellcheck="false">
          <button class="party-btn" id="btn-make-party">MAKE PARTY</button>
          <button class="party-btn" id="btn-join-party">JOIN PARTY</button>
          <button class="party-btn" id="btn-vs-cpu">VS CPU</button>
          <div id="party-status"></div>
        </div>
        <div id="waiting-screen" style="display:none">
          <div class="waiting-text">WAITING FOR OPPONENT...</div>
          <div class="waiting-code" id="waiting-code"></div>
          <button id="btn-cancel-party">CANCEL</button>
        </div>
      </div>
      <div id="disconnect-msg">
        <div class="dc-text">OPPONENT LEFT</div>
        <button id="btn-dc-ok">OK</button>
      </div>
    </div>
    <div id="controls">
      <span>A/D</span> MOVE &nbsp; <span>W</span> UP &nbsp; <span>S/RMB</span> BLOCK &nbsp;
      <span>LMB</span> JAB &nbsp; <span>E</span> CROSS &nbsp;
      <span>R</span> HOOK &nbsp; <span>F</span> UPPERCUT &nbsp;
      <span>Q</span> BODY &nbsp; <span>SPACE</span> JUMP<br>
      <span>2xA/D+LMB</span> DASH PUNCH &nbsp; <span>MOUSE</span> AIM
    </div>
  </div>

  <script>
    // ============================================================
    //  KNOCKOUT! v2 — Retro 2D Boxing Game (Full Overhaul)
    // ============================================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // ── Mouse tracking ──
    let mouseX = W / 2, mouseY = H / 2;
    const canvasRect = () => canvas.getBoundingClientRect();
    canvas.addEventListener('mousemove', e => {
      const r = canvasRect();
      mouseX = (e.clientX - r.left) * (W / r.width);
      mouseY = (e.clientY - r.top) * (H / r.height);
    });

    // ── Color Palette ──
    const C = {
      bg: '#1a1020', ring: '#2a1a30', ropes: '#e84040', ropeShadow: '#a02020',
      post: '#c8a860', floor: '#3a2a40', floorLine: '#4a3a55',
      p1: '#4488ff', p1dark: '#2255bb', p1skin: '#ffcc88', p1glove: '#ff4444',
      p1skinShd: '#dda866', p1hair: '#3a2210', p1shoe: '#222244', p1trim: '#66aaff',
      p2: '#ff5533', p2dark: '#bb2211', p2skin: '#eebb77', p2glove: '#4444ff',
      p2skinShd: '#cc9955', p2hair: '#1a1a1a', p2shoe: '#442222', p2trim: '#ff8866',
      white: '#ffffff', black: '#000000',
      hpGreen: '#44dd44', hpYellow: '#dddd44', hpRed: '#dd4444',
      stamina: '#44aaff', gold: '#ffdd44', textShadow: '#220a00',
    };

    // ── Game State ──
    let gameState = 'TITLE';
    let roundNumber = 1, roundTimer = 99, roundTimerAccum = 0;
    let koTimer = 0, koTarget = null;
    let shakeX = 0, shakeY = 0, shakeDur = 0;
    let freezeFrames = 0, particles = [], floatingTexts = [];
    let flashAlpha = 0, titleBlink = 0;
    let comboCount = 0, comboTimer = 0, lastAttacker = null;
    let slowMoTimer = 0, slowMoScale = 1;
    let ropeVibrationL = 0, ropeVibrationR = 0; // rope vibration amplitude
    let cameraFlashTimer = 0;
    let victoryTimer = 0;

    // ── Input ──
    const keys = {};
    const keyDownTimes = {};
    let lastDirTap = { dir: 0, time: 0 };
    let dashPunchReady = false;
    window.addEventListener('keydown', e => {
      if (!keys[e.code]) keyDownTimes[e.code] = performance.now();
      keys[e.code] = true;
      e.preventDefault();
      // Dash punch detection: double-tap A or D
      const now = performance.now();
      if (e.code === 'KeyA' || e.code === 'KeyD') {
        const dir = e.code === 'KeyD' ? 1 : -1;
        if (dir === lastDirTap.dir && now - lastDirTap.time < 300) {
          dashPunchReady = true;
        }
        lastDirTap = { dir, time: now };
      }
    });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    // ── Mouse click (LMB = jab / dash punch, RMB = block) ──
    let mouseDown = false;
    let rmbDown = false;
    canvas.addEventListener('mousedown', e => {
      if (e.button === 0) { mouseDown = true; e.preventDefault(); }
      if (e.button === 2) { rmbDown = true; e.preventDefault(); }
    });
    canvas.addEventListener('mouseup', e => {
      if (e.button === 0) mouseDown = false;
      if (e.button === 2) rmbDown = false;
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // ── Ring ──
    const RING = { x: 60, y: 180, w: 520, h: 170 };
    const RING_CENTER_X = RING.x + RING.w / 2;

    // ── Punch Definitions ──
    const PUNCHES = {
      jab: { name: 'JAB', dmg: 5, staCost: 8, reach: 45, dur: 250, headMult: 1.3, bodyShot: false, leanX: 0, leanY: 0, armStyle: 'straight' },
      cross: { name: 'CROSS', dmg: 10, staCost: 25, reach: 55, dur: 400, headMult: 1.5, bodyShot: false, leanX: 3, leanY: 0, armStyle: 'straight' },
      hook: { name: 'HOOK', dmg: 15, staCost: 35, reach: 35, dur: 380, headMult: 1.8, bodyShot: false, leanX: 5, leanY: 0, armStyle: 'hook' },
      uppercut: { name: 'UPPERCUT', dmg: 22, staCost: 50, reach: 30, dur: 550, headMult: 2.0, bodyShot: false, leanX: 0, leanY: -3, armStyle: 'uppercut' },
      bodyshot: { name: 'BODY', dmg: 4, staCost: 10, reach: 30, dur: 250, headMult: 1.0, bodyShot: true, leanX: 4, leanY: 3, armStyle: 'straight', staDmg: 18 },
      dashpunch: { name: 'DASH', dmg: 12, staCost: 35, reach: 60, dur: 350, headMult: 1.4, bodyShot: false, leanX: 8, leanY: 0, armStyle: 'straight', dashForce: 5 },
    };
    const PUNCHES_BY_NAME = {};
    for (const [k, p] of Object.entries(PUNCHES)) PUNCHES_BY_NAME[p.name] = p;

    // ── Online Mode State ──
    let isOnlineMode = false;
    let showPartyMenu = false;
    let syncCounter = 0;
    const SYNC_RATE = 4;
    let remoteGameState = null;
    let guestActionCounts = { jab: 0, cross: 0, hook: 0, upper: 0, body: 0, jump: 0, dash: 0 };
    let lastHostActionCounts = { jab: 0, cross: 0, hook: 0, upper: 0, body: 0, jump: 0, dash: 0 };

    // ── Character Roster ──
    let selectedCharIdx = 0;
    const CHARACTERS = [
      {
        name: 'FLASH',
        title: 'SPEED DEMON',
        desc: 'Lightning fast, glass cannon',
        // Stats (very different!)
        hp: 65, stamina: 130, speed: 5.5, retreatMod: 0.9, jumpForce: -10, blockDmgReduction: 0.6,
        dmgMult: 0.7, staminaRegen: 20,
        // Visual: small, lean build
        bodyScale: 0.85, headSize: 0.9, armThick: 3, legThick: 3.5,
        hairStyle: 'mohawk',
        colors: {
          main: '#22ccff', dark: '#1188aa', skin: '#ddb888', glove: '#ff2222',
          skinShd: '#bb9566', hair: '#ffdd00', shoe: '#111133', trim: '#22eeff'
        },
        // Stat display values (out of 5)
        statBars: { SPD: 5, PWR: 2, HP: 2, STA: 5, DEF: 1 }
      },
      {
        name: 'TANK',
        title: 'THE BRUISER',
        desc: 'Slow but devastating power',
        hp: 160, stamina: 70, speed: 1.8, retreatMod: 0.5, jumpForce: -6, blockDmgReduction: 0.85,
        dmgMult: 1.6, staminaRegen: 6,
        // Visual: big, wide build
        bodyScale: 1.25, headSize: 1.1, armThick: 7, legThick: 6,
        hairStyle: 'bald',
        colors: {
          main: '#ff4422', dark: '#aa2211', skin: '#c49960', glove: '#333333',
          skinShd: '#a07740', hair: '#c49960', shoe: '#441111', trim: '#ff6644'
        },
        statBars: { SPD: 1, PWR: 5, HP: 5, STA: 2, DEF: 5 }
      },
      {
        name: 'ACE',
        title: 'ALL-ROUNDER',
        desc: 'Balanced fighter, jack of all trades',
        hp: 100, stamina: 100, speed: 3, retreatMod: 0.7, jumpForce: -8, blockDmgReduction: 0.7,
        dmgMult: 1.0, staminaRegen: 12,
        // Visual: medium build
        bodyScale: 1.0, headSize: 1.0, armThick: 5, legThick: 5,
        hairStyle: 'short',
        colors: {
          main: '#4488ff', dark: '#2255bb', skin: '#ffcc88', glove: '#ff4444',
          skinShd: '#dda866', hair: '#3a2210', shoe: '#222244', trim: '#66aaff'
        },
        statBars: { SPD: 3, PWR: 3, HP: 3, STA: 3, DEF: 3 }
      }
    ];

    // ── Floating damage text ──
    function spawnFloatingText(x, y, text, color) {
      floatingTexts.push({ x, y, text, color, life: 1.0, vy: -1.5 });
    }

    // ── Boxer Class ──
    class Boxer {
      constructor(x, facing, colors, name, isPlayer = false) {
        this.x = x;
        this.groundY = RING.y + RING.h - 10;
        this.y = this.groundY;
        this.facing = facing;
        this.colors = colors;
        this.name = name;
        this.isPlayer = isPlayer;

        this.hp = 100; this.maxHp = 100;
        this.stamina = 100; this.maxStamina = 100;
        this.score = 0;

        this.vx = 0; this.speed = 3; this.retreatMod = 0.7;

        // Ring depth (vertical position within ring)
        this.ringZ = 0; // 0 = bottom of ring, negative = toward top
        this.vzRing = 0; // vertical ring velocity
        this.ringZSpeed = 2.5;
        this.baseGroundY = RING.y + RING.h - 10;

        // Jump
        this.vy = 0; this.isGrounded = true;
        this.jumpForce = -8; this.gravity = 0.4;

        // Combat
        this.attacking = false; this.currentPunch = null;
        this.attackTimer = 0; this.attackCooldown = 0;
        this.hitRegistered = false;
        this.blocking = false; this.blockDmgReduction = 0.7;
        this.blockStartTime = 0; // for perfect block timing

        // Physics
        this.knockbackVx = 0;

        // Animation state
        this.bobPhase = Math.random() * Math.PI * 2;
        this.hitFlash = 0; this.punchArmExt = 0; this.bodyLean = 0;
        this.stunTimer = 0;       // stun on heavy headshot
        this.staggerPhase = 0;   // low HP stagger
        this.headSnapBack = 0;   // head snap-back on hit
        this.breathPhase = 0;    // idle breathing

        // Mouse aim offset for player (vertical glove target)
        this.aimY = 0; // -1 = head, 0 = mid, 1 = body
        this.mouseAimAngle = 0; // angle from shoulder to mouse cursor
      }

      get centerX() { return this.x; }
      get headY() { return this.y - 55 + Math.sin(this.bobPhase) * 2 + this.breathAnim; }
      get bodyY() { return this.y - 30; }
      get breathAnim() { return Math.sin(this.breathPhase) * 1.2; }
      get isStunned() { return this.stunTimer > 0; }

      update(dt) {
        this.bobPhase += dt * 4;
        this.breathPhase += dt * 2.5;

        // Stun timer
        if (this.stunTimer > 0) { this.stunTimer -= dt; this.attacking = false; }

        // Stagger at low HP
        if (this.hp / this.maxHp < 0.25) {
          this.staggerPhase += dt * 6;
        } else {
          this.staggerPhase *= 0.9;
        }

        // Head snap decay
        this.headSnapBack *= 0.85;

        // Cooldowns
        if (this.attackCooldown > 0) this.attackCooldown -= dt * 1000;
        if (this.hitFlash > 0) this.hitFlash -= dt;

        // Attack timer
        if (this.attacking && !this.isStunned) {
          this.attackTimer -= dt * 1000;
          let progress = 1 - (this.attackTimer / this.currentPunch.dur);
          if (progress < 0.3) this.punchArmExt = progress / 0.3;
          else if (progress > 0.7) this.punchArmExt = (1 - progress) / 0.3;
          else this.punchArmExt = 1;
          if (this.attackTimer <= 0) {
            this.attacking = false; this.currentPunch = null;
            this.punchArmExt = 0; this.attackCooldown = 150;
          }
        }

        // Stamina regen
        if (!this.attacking && !this.blocking) {
          this.stamina = Math.min(this.maxStamina, this.stamina + (this.staminaRegen || 12) * dt);
        }

        // Jump / Gravity
        this.vy += this.gravity;
        this.y += this.vy;
        if (this.y >= this.groundY) {
          if (!this.isGrounded && Math.abs(this.vy) > 2) spawnHitParticles(this.x, this.groundY, '#aa9977', 4);
          this.y = this.groundY; this.vy = 0; this.isGrounded = true;
        } else { this.isGrounded = false; }
        if (!this.isGrounded) this.blocking = false;

        // Movement + knockback
        this.x += (this.vx + this.knockbackVx) * dt * 60;
        this.knockbackVx *= 0.88;
        if (Math.abs(this.knockbackVx) < 0.1) this.knockbackVx = 0;
        this.bodyLean += (this.vx * 0.8 - this.bodyLean) * 0.15;

        // Elastic rope bounce
        const ROPE_ZONE = 35, SPRING_K = 0.35, HARD_EDGE = 15;
        const leftEdge = RING.x + HARD_EDGE, rightEdge = RING.x + RING.w - HARD_EDGE;
        const leftPen = (RING.x + ROPE_ZONE) - this.x;
        if (leftPen > 0) {
          const force = SPRING_K * leftPen;
          this.knockbackVx += force;
          if (force > 1.5) {
            triggerShake(force * 0.5, force * 40);
            if (force > 3) { this.vy -= force * 0.3; spawnHitParticles(RING.x, this.y - 30, '#e84040', 3); ropeVibrationL = force * 2; }
          }
        }
        const rightPen = this.x - (RING.x + RING.w - ROPE_ZONE);
        if (rightPen > 0) {
          const force = SPRING_K * rightPen;
          this.knockbackVx -= force;
          if (force > 1.5) {
            triggerShake(force * 0.5, force * 40);
            if (force > 3) { this.vy -= force * 0.3; spawnHitParticles(RING.x + RING.w, this.y - 30, '#e84040', 3); ropeVibrationR = force * 2; }
          }
        }
        if (this.x < leftEdge) { this.x = leftEdge; this.knockbackVx = Math.abs(this.knockbackVx) * 0.3; }
        if (this.x > rightEdge) { this.x = rightEdge; this.knockbackVx = -Math.abs(this.knockbackVx) * 0.3; }
        this.vx = 0;

        // Ring depth movement (vertical)
        this.ringZ += this.vzRing * dt * 60;
        // Clamp within ring area (can move up to ~130px up from baseline)
        const maxUp = -(RING.h - 40);
        if (this.ringZ < maxUp) this.ringZ = maxUp;
        if (this.ringZ > 0) this.ringZ = 0;
        // Auto-drift back toward baseline when not moving
        if (this.vzRing === 0 && this.ringZ < 0) {
          this.ringZ = Math.min(0, this.ringZ + 1.5 * dt * 60);
        }
        this.groundY = this.baseGroundY + this.ringZ;
        this.vzRing = 0;
      }

      move(dir) {
        if (this.attacking || this.isStunned) return;
        let spd = this.speed;
        if ((dir > 0 && this.facing < 0) || (dir < 0 && this.facing > 0)) spd *= this.retreatMod;
        this.vx = dir * spd;
      }

      jump() {
        if (!this.isGrounded || this.attacking || this.isStunned) return;
        this.vy = this.jumpForce; this.isGrounded = false;
      }

      moveZ(dir) {
        if (this.attacking || this.isStunned) return;
        this.vzRing = dir * this.ringZSpeed;
      }

      punch(type) {
        if (this.attacking || this.attackCooldown > 0 || this.blocking || !this.isGrounded || this.isStunned) return;
        const p = PUNCHES[type];
        if (!p || this.stamina < p.staCost) return;
        this.stamina -= p.staCost;
        this.attacking = true; this.currentPunch = p;
        this.attackTimer = p.dur; this.hitRegistered = false;
        // Dash punch forward burst
        if (p.dashForce) this.knockbackVx += this.facing * p.dashForce;
      }

      getHitbox() {
        if (!this.attacking || !this.currentPunch || this.hitRegistered) return null;
        const ext = this.punchArmExt;
        if (ext < 0.7) return null;
        const p = this.currentPunch;
        const hx = this.x + this.facing * (15 + p.reach * ext);
        // Mouse aim shifts hitbox Y for player
        let hy = this.headY - 5 + (this.isPlayer ? this.aimY * 15 : 0);
        if (p.bodyShot) hy = this.bodyY - 5;
        return { x: hx - 12, y: hy, w: 24, h: p.bodyShot ? 20 : 30 };
      }

      getHurtbox() {
        return { x: this.x - 14, y: this.headY - 10, w: 28, h: 65 };
      }

      takeDamage(dmg, attackerX, punch, isHead) {
        let finalDmg = dmg;
        // Perfect block: if block started < 150ms ago, extra reduction
        let perfectBlock = false;
        if (this.blocking) {
          const blockDur = performance.now() - this.blockStartTime;
          if (blockDur < 150) {
            finalDmg *= 0.1; // 90% reduction on perfect block
            perfectBlock = true;
            spawnFloatingText(this.x, this.headY - 20, 'PERFECT!', '#44ffff');
          } else {
            finalDmg *= (1 - this.blockDmgReduction);
          }
          this.stamina -= (perfectBlock ? dmg * 0.1 : dmg * 0.3);
        }

        // Body shot: extra stamina damage
        if (punch && punch.bodyShot) {
          this.stamina -= (punch.staDmg || 15);
          if (this.stamina < 0) this.stamina = 0;
        }

        this.hp -= finalDmg;
        this.hitFlash = 0.15;

        // Head snap-back on heavy hit
        if (isHead && finalDmg > 8) {
          this.headSnapBack = Math.min(8, finalDmg * 0.4) * (attackerX < this.x ? 1 : -1);
        }

        // Stun on strong headshot
        if (isHead && finalDmg > 18 && !this.blocking) {
          this.stunTimer = 0.4 + finalDmg * 0.01;
          spawnFloatingText(this.x, this.headY - 30, 'STUN!', '#ffff44');
        }

        // Knockback + uppercut vertical launch
        const dir = attackerX < this.x ? 1 : -1;
        this.knockbackVx += dir * (finalDmg * 0.25);
        if (punch && punch.name === 'UPPERCUT' && finalDmg > 10) {
          this.vy -= Math.min(4, finalDmg * 0.12);
        }

        // Floating damage number
        if (finalDmg > 0.5) {
          const col = isHead ? '#ffff44' : (punch && punch.bodyShot ? '#44aaff' : '#ff8844');
          spawnFloatingText(this.x + (Math.random() - 0.5) * 20, this.headY - 15, Math.round(finalDmg).toString(), col);
        }
      }

      draw(ctx) {
        const bob = Math.sin(this.bobPhase) * 2 + this.breathAnim;
        const stagger = Math.sin(this.staggerPhase) * (this.hp / this.maxHp < 0.25 ? 2 : 0);
        const lean = this.bodyLean + stagger;
        const f = this.facing;
        const flash = this.hitFlash > 0;
        const punchLean = this.currentPunch ? this.currentPunch.leanX * this.punchArmExt * f : 0;
        const punchLeanY = this.currentPunch ? this.currentPunch.leanY * this.punchArmExt : 0;
        const lx = lean + punchLean; // combined lean X
        const ly = punchLeanY;       // combined lean Y
        const sk = flash ? '#fff' : this.colors.skin;
        const skShd = flash ? '#ddd' : (this.colors.skinShd || this.colors.skin);
        const mainC = flash ? '#fff' : this.colors.main;
        const darkC = flash ? '#ddd' : this.colors.dark;
        const gc = flash ? '#fff' : this.colors.glove;
        const hairC = flash ? '#eee' : (this.colors.hair || this.colors.dark);
        const shoeC = flash ? '#fff' : (this.colors.shoe || '#222');
        const trimC = flash ? '#fff' : (this.colors.trim || this.colors.main);
        const now = performance.now();

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';

        // ── Ground Shadow ──
        const jumpH = this.groundY - this.y;
        const ss = Math.max(0.3, 1 - jumpH / 80);
        ctx.fillStyle = `rgba(0,0,0,${0.35 * ss})`;
        ctx.beginPath();
        ctx.ellipse(0, this.groundY - this.y + 2, 22 * ss, 6 * ss, 0, 0, Math.PI * 2);
        ctx.fill();

        // ── Helper: draw a two-segment limb with joint ──
        const drawLimb = (sx, sy, ex, ey, thickness, color, jointR) => {
          const mx = (sx + ex) * 0.5 + (ey - sy) * 0.15 * f;
          const my = (sy + ey) * 0.5 + (sx - ex) * 0.05;
          ctx.strokeStyle = color; ctx.lineWidth = thickness;
          ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(mx, my); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(mx, my); ctx.lineTo(ex, ey); ctx.stroke();
          // Joint circle
          ctx.fillStyle = color;
          ctx.beginPath(); ctx.arc(mx, my, jointR, 0, Math.PI * 2); ctx.fill();
        };

        // ── Legs (two-segment with knee + boxing boots) ──
        const hipY = -12 + bob + ly;
        // Back leg
        const blHipX = -f * 5 + lx, blFootX = -f * 12;
        drawLimb(blHipX, hipY, blFootX, -1, 5, skShd, 2.5);
        // Boot
        ctx.fillStyle = shoeC;
        ctx.beginPath();
        ctx.ellipse(blFootX, 0, 5, 3, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = darkC;
        ctx.fillRect(blFootX - 4, -3, 8, 2); // boot cuff

        // Front leg
        const flHipX = f * 5 + lx, flFootX = f * 12;
        drawLimb(flHipX, hipY, flFootX, -1, 5.5, sk, 2.5);
        // Boot
        ctx.fillStyle = shoeC;
        ctx.beginPath();
        ctx.ellipse(flFootX, 0, 5, 3, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = darkC;
        ctx.fillRect(flFootX - 4, -3, 8, 2); // boot cuff
        // Lace detail
        ctx.strokeStyle = '#888'; ctx.lineWidth = 0.5;
        for (let li = 0; li < 3; li++) {
          const liy = -1 + li * 1.5;
          ctx.beginPath(); ctx.moveTo(flFootX - 2, liy - 3); ctx.lineTo(flFootX + 2, liy - 3); ctx.stroke();
        }

        // ── Shorts (shaped with waistband + trim stripe) ──
        ctx.fillStyle = mainC;
        ctx.beginPath();
        ctx.moveTo(-9 + lx, -18 + bob + ly);
        ctx.lineTo(9 + lx, -18 + bob + ly);
        ctx.lineTo(10 + lx, -9 + bob + ly);
        ctx.lineTo(2 + lx, -8 + bob + ly);
        ctx.lineTo(-2 + lx, -8 + bob + ly);
        ctx.lineTo(-10 + lx, -9 + bob + ly);
        ctx.closePath(); ctx.fill();
        // Waistband
        ctx.fillStyle = darkC;
        ctx.fillRect(-9 + lx, -18 + bob + ly, 18, 3);
        // Trim stripe at bottom
        ctx.strokeStyle = trimC; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-10 + lx, -10 + bob + ly);
        ctx.lineTo(10 + lx, -10 + bob + ly); ctx.stroke();

        // ── Torso (tapered trapezoid with muscle definition) ──
        // Body shape
        ctx.fillStyle = sk;
        ctx.beginPath();
        ctx.moveTo(-9 + lx, -18 + bob + ly);  // waist left
        ctx.lineTo(-11 + lx, -32 + bob + ly); // shoulder left
        ctx.lineTo(11 + lx, -32 + bob + ly);  // shoulder right
        ctx.lineTo(9 + lx, -18 + bob + ly);   // waist right
        ctx.closePath(); ctx.fill();

        // Shoulder caps
        ctx.fillStyle = sk;
        ctx.beginPath(); ctx.arc(-11 + lx, -32 + bob + ly, 4, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(11 + lx, -32 + bob + ly, 4, 0, Math.PI * 2); ctx.fill();

        // Body shading (shadow on far side from ring center spotlight)
        ctx.fillStyle = skShd;
        ctx.globalAlpha = 0.35;
        ctx.beginPath();
        ctx.moveTo(-f * 1 + lx, -18 + bob + ly);
        ctx.lineTo(-f * 1 + lx, -32 + bob + ly);
        ctx.lineTo(-f * 11 + lx, -32 + bob + ly);
        ctx.lineTo(-f * 9 + lx, -18 + bob + ly);
        ctx.closePath(); ctx.fill();
        ctx.globalAlpha = 1;

        // Pec / chest line
        if (!flash) {
          ctx.strokeStyle = skShd; ctx.lineWidth = 0.8; ctx.globalAlpha = 0.5;
          // Center chest line
          ctx.beginPath();
          ctx.moveTo(lx, -31 + bob + ly); ctx.lineTo(lx, -24 + bob + ly); ctx.stroke();
          // Pec curves
          ctx.beginPath();
          ctx.arc(lx - 5, -29 + bob + ly, 5, -0.3, 1.2); ctx.stroke();
          ctx.beginPath();
          ctx.arc(lx + 5, -29 + bob + ly, 5, Math.PI - 1.2, Math.PI + 0.3); ctx.stroke();
          // Ab lines (horizontal)
          for (let ai = 0; ai < 2; ai++) {
            const ay = -23 + ai * 4 + bob + ly;
            ctx.beginPath(); ctx.moveTo(-4 + lx, ay); ctx.lineTo(4 + lx, ay); ctx.stroke();
          }
          ctx.globalAlpha = 1;
        }

        // ── Arms & Gloves ──
        const isIdlePlayer = this.isPlayer && !this.attacking && !this.blocking && !this.isStunned;
        const shoulderBackX = -f * 11 + lx, shoulderFrontX = f * 11 + lx;
        const shoulderY = -33 + bob + ly;

        // Helper: draw arm with upper/forearm segments, elbow joint, and glove
        const drawArm = (sx, sy, ex, ey, thick, gloveR, isBack) => {
          // Two-segment arm: shoulder→elbow→glove
          const elbMidX = (sx + ex) * 0.5;
          const elbMidY = (sy + ey) * 0.5;
          // Offset elbow slightly outward and downward
          const elbX = elbMidX + (ey - sy) * 0.2 * f;
          const elbY = elbMidY + Math.abs(ex - sx) * 0.15;
          // Upper arm
          ctx.strokeStyle = sk; ctx.lineWidth = thick + 1;
          ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(elbX, elbY); ctx.stroke();
          // Forearm (slightly thinner)
          ctx.lineWidth = thick;
          ctx.beginPath(); ctx.moveTo(elbX, elbY); ctx.lineTo(ex, ey); ctx.stroke();
          // Elbow joint
          ctx.fillStyle = sk;
          ctx.beginPath(); ctx.arc(elbX, elbY, thick * 0.45, 0, Math.PI * 2); ctx.fill();
          // Wrist wrap
          const wx = ex + (elbX - ex) * 0.2;
          const wy = ey + (elbY - ey) * 0.2;
          ctx.strokeStyle = '#ddd'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(wx - 2, wy); ctx.lineTo(wx + 2, wy); ctx.stroke();
          // Glove
          ctx.fillStyle = gc;
          ctx.beginPath(); ctx.arc(ex, ey, gloveR, 0, Math.PI * 2); ctx.fill();
          // Glove highlight
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath(); ctx.arc(ex - 1, ey - 2, gloveR * 0.5, 0, Math.PI * 2); ctx.fill();
          // Glove outline
          ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.arc(ex, ey, gloveR, 0, Math.PI * 2); ctx.stroke();
          // Thumb nub
          const thumbDir = isBack ? -f : f;
          ctx.fillStyle = gc;
          ctx.beginPath(); ctx.arc(ex + thumbDir * gloveR * 0.6, ey + 2, gloveR * 0.3, 0, Math.PI * 2); ctx.fill();
        };

        if (isIdlePlayer) {
          // ── Mouse-aim: both arms stretch toward cursor ──
          const armLen = 25;
          const angle = this.mouseAimAngle;
          const aimDx = Math.cos(angle) * armLen;
          const aimDy = Math.sin(angle) * armLen;

          // Back arm
          const bsx = shoulderBackX, bsy = shoulderY;
          drawArm(bsx, bsy, bsx + aimDx * 0.9, bsy + aimDy * 0.9, 4, 6, true);
          // Front arm
          const fsx = shoulderFrontX, fsy = shoulderY;
          drawArm(fsx, fsy, fsx + aimDx, fsy + aimDy, 4.5, 7, false);
        } else {
          // ── Back arm (default / blocking / stunned) ──
          const baex = -f * 16 + lx;
          const baey = -26 + bob + (this.blocking ? -10 : 0) + ly;
          drawArm(shoulderBackX, shoulderY, baex, baey, 4, 6, true);

          // ── Front arm (punching / blocking / stunned) ──
          const ext = this.punchArmExt;
          let fex = f * 16 + lx, fey = -33 + bob + ly;
          if (this.attacking && this.currentPunch) {
            const p = this.currentPunch;
            if (p.armStyle === 'hook') {
              fex = f * (16 + p.reach * ext * 0.6) + lx;
              fey = -30 + bob - ext * 4 + ly;
            } else if (p.armStyle === 'uppercut') {
              fex = f * (16 + p.reach * ext * 0.5) + lx;
              fey = -33 + bob - ext * 12 + ly;
            } else {
              fex = f * (16 + p.reach * ext) + lx;
              fey = -33 + bob + ly;
            }
          }
          if (this.blocking) { fex = f * 8 + lean; fey = -36 + bob; }
          if (this.isStunned) {
            fex += Math.sin(now * 0.02) * 4;
            fey += Math.cos(now * 0.015) * 3;
          }
          drawArm(shoulderFrontX, shoulderY, fex, fey, 4.5, 7, false);
        }

        // ── Head ──
        const headOff = this.headSnapBack;
        const hx = lx + headOff;
        const hy = -46 + bob + ly;

        // Neck
        ctx.strokeStyle = sk; ctx.lineWidth = 5;
        ctx.beginPath(); ctx.moveTo(lx, -33 + bob + ly); ctx.lineTo(hx, hy + 8); ctx.stroke();

        // Head base (slightly oval)
        ctx.fillStyle = sk;
        ctx.beginPath(); ctx.ellipse(hx, hy, 9, 10.5, 0, 0, Math.PI * 2); ctx.fill();

        // Jaw definition
        ctx.fillStyle = skShd; ctx.globalAlpha = 0.2;
        ctx.beginPath();
        ctx.ellipse(hx, hy + 4, 7.5, 5, 0, 0, Math.PI); ctx.fill();
        ctx.globalAlpha = 1;

        // Hair (cropped / fade style)
        ctx.fillStyle = hairC;
        ctx.beginPath();
        ctx.ellipse(hx, hy - 3, 9.5, 8, 0, Math.PI, Math.PI * 2); ctx.fill();
        // Hair fade line
        ctx.strokeStyle = hairC; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(hx, hy, 9.5, Math.PI + 0.3, Math.PI * 2 - 0.3); ctx.stroke();
        ctx.globalAlpha = 1;

        // Ear (on far side)
        ctx.fillStyle = sk;
        ctx.beginPath(); ctx.ellipse(hx - f * 9, hy, 2.5, 3.5, 0, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = skShd; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.arc(hx - f * 9, hy, 1.5, 0, Math.PI); ctx.stroke();

        if (!flash) {
          // Eyebrow
          ctx.strokeStyle = hairC; ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(hx + f * 2, hy - 5);
          ctx.lineTo(hx + f * 7, hy - 5.5 + (this.isStunned ? 2 : 0));
          ctx.stroke();

          // Eye
          if (!this.isStunned) {
            // Eye white
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.ellipse(hx + f * 5, hy - 2, 2.5, 2, 0, 0, Math.PI * 2); ctx.fill();
            // Pupil
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.arc(hx + f * 5.5, hy - 1.5, 1.2, 0, Math.PI * 2); ctx.fill();
          } else {
            // Stunned X eye
            ctx.strokeStyle = '#555'; ctx.lineWidth = 1.5;
            const ex0 = hx + f * 5, ey0 = hy - 2;
            ctx.beginPath(); ctx.moveTo(ex0 - 2, ey0 - 2); ctx.lineTo(ex0 + 2, ey0 + 2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(ex0 + 2, ey0 - 2); ctx.lineTo(ex0 - 2, ey0 + 2); ctx.stroke();
          }

          // Nose
          ctx.strokeStyle = skShd; ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(hx + f * 6, hy - 1);
          ctx.lineTo(hx + f * 7.5, hy + 1.5);
          ctx.lineTo(hx + f * 5.5, hy + 2);
          ctx.stroke();

          // Mouth
          ctx.strokeStyle = '#a06040'; ctx.lineWidth = 1;
          if (this.hp / this.maxHp < 0.3) {
            // Grimace when hurt
            ctx.beginPath();
            ctx.arc(hx + f * 3, hy + 5, 3, 0.2, Math.PI - 0.2); ctx.stroke();
          } else {
            // Neutral/slight grin
            ctx.beginPath();
            ctx.moveTo(hx + f * 2, hy + 4.5);
            ctx.lineTo(hx + f * 6, hy + 4);
            ctx.stroke();
          }
        }

        // ── Sweat drops when stamina low ──
        if (!flash && this.stamina / this.maxStamina < 0.35) {
          ctx.fillStyle = '#88ccff'; ctx.globalAlpha = 0.6;
          const swPhase = now * 0.003 + this.bobPhase;
          for (let si = 0; si < 2; si++) {
            const sdx = Math.sin(swPhase + si * 3) * 8;
            const sdy = (now * 0.04 + si * 20) % 30 - 15;
            ctx.beginPath(); ctx.arc(hx + sdx, hy - 5 + sdy, 1.2, 0, Math.PI * 2); ctx.fill();
          }
          ctx.globalAlpha = 1;
        }

        ctx.restore();
      }
    }

    // ── Fighters ──
    let player, enemy;
    function resetFighters() {
      const ch = CHARACTERS[selectedCharIdx];
      player = new Boxer(RING.x + 120, 1, {
        main: ch.colors.main, dark: ch.colors.dark, skin: ch.colors.skin, glove: ch.colors.glove,
        skinShd: ch.colors.skinShd, hair: ch.colors.hair, shoe: ch.colors.shoe, trim: ch.colors.trim
      }, ch.name, true);
      // Apply character stats to player
      player.hp = ch.hp; player.maxHp = ch.hp;
      player.stamina = ch.stamina; player.maxStamina = ch.stamina;
      player.speed = ch.speed; player.retreatMod = ch.retreatMod;
      player.jumpForce = ch.jumpForce; player.blockDmgReduction = ch.blockDmgReduction;
      player.dmgMult = ch.dmgMult; player.staminaRegen = ch.staminaRegen;
      player.bodyScale = ch.bodyScale; player.headSize = ch.headSize;
      player.armThick = ch.armThick; player.legThick = ch.legThick;
      player.hairStyle = ch.hairStyle;

      // CPU always picks a random different character
      let cpuIdx = Math.floor(Math.random() * CHARACTERS.length);
      while (cpuIdx === selectedCharIdx && CHARACTERS.length > 1) cpuIdx = Math.floor(Math.random() * CHARACTERS.length);
      const cpuCh = CHARACTERS[cpuIdx];
      enemy = new Boxer(RING.x + RING.w - 120, -1, {
        main: cpuCh.colors.main, dark: cpuCh.colors.dark, skin: cpuCh.colors.skin, glove: cpuCh.colors.glove,
        skinShd: cpuCh.colors.skinShd, hair: cpuCh.colors.hair, shoe: cpuCh.colors.shoe, trim: cpuCh.colors.trim
      }, cpuCh.name, false);
      enemy.hp = cpuCh.hp; enemy.maxHp = cpuCh.hp;
      enemy.stamina = cpuCh.stamina; enemy.maxStamina = cpuCh.stamina;
      enemy.speed = cpuCh.speed; enemy.retreatMod = cpuCh.retreatMod;
      enemy.jumpForce = cpuCh.jumpForce; enemy.blockDmgReduction = cpuCh.blockDmgReduction;
      enemy.dmgMult = cpuCh.dmgMult; enemy.staminaRegen = cpuCh.staminaRegen;
      enemy.bodyScale = cpuCh.bodyScale; enemy.headSize = cpuCh.headSize;
      enemy.armThick = cpuCh.armThick; enemy.legThick = cpuCh.legThick;
      enemy.hairStyle = cpuCh.hairStyle;
    }
    function resetRound() {
      resetFighters();
      roundTimer = 99; roundTimerAccum = 0;
      particles = []; floatingTexts = [];
      flashAlpha = 0; freezeFrames = 0; shakeDur = 0;
      comboCount = 0; comboTimer = 0;
      slowMoTimer = 0; slowMoScale = 1;
      ropeVibrationL = 0; ropeVibrationR = 0;
      victoryTimer = 0;
      gameState = 'FIGHTING';
    }
    function startGame() {
      roundNumber = 1;
      if (player) player.score = 0;
      if (enemy) enemy.score = 0;
      resetRound();
    }

    // ── Smart AI Controller ──
    const AI = {
      state: 'IDLE', lastDecision: 0, comboStep: 0, comboSeq: null,
      feinting: false, feintTimer: 0,

      getReactionDelay() { return Math.max(200, 700 - roundNumber * 50) + Math.random() * 200; },
      getAggression() { return Math.min(0.95, 0.3 + roundNumber * 0.08); },

      update(dt, cpu, target) {
        const now = performance.now();
        const dist = Math.abs(cpu.x - target.x);
        const tHpPct = target.hp / target.maxHp;
        const cHpPct = cpu.hp / cpu.maxHp;
        const cStaPct = cpu.stamina / cpu.maxStamina;
        const tStaPct = target.stamina / target.maxStamina;
        const aggression = this.getAggression();

        // Feint timer
        if (this.feinting) { this.feintTimer -= dt * 1000; if (this.feintTimer <= 0) this.feinting = false; }

        if (now - this.lastDecision > this.getReactionDelay()) {
          this.lastDecision = now;

          // Counterattack: if target just whiffed (attacking but no hit registered and timer almost done)
          if (target.attacking && !target.hitRegistered && target.attackTimer < 100 && dist < 80) {
            this.state = 'COUNTER';
          } else if (cpu.stamina < 20) {
            this.state = 'RETREAT';
          } else if (dist > 180) {
            this.state = 'CHASE';
          } else if (dist < 40) {
            this.state = Math.random() < 0.4 ? 'RETREAT' : 'PRESSURE';
          } else if (dist <= 100 && cStaPct > 0.3) {
            this.state = Math.random() < aggression ? 'ATTACK' : 'IDLE';
          } else {
            this.state = 'IDLE';
          }
        }

        const dir = target.x > cpu.x ? 1 : -1;
        cpu.blocking = false;

        // AI Z-tracking: wobbly, delayed tracking of player's ring depth
        const wobble = Math.sin(now * 0.002 + cpu.x * 0.1) * 20;
        const zDiff = (target.groundY + wobble) - cpu.groundY;
        if (Math.abs(zDiff) > 30 && Math.random() < 0.6) {
          cpu.moveZ(zDiff < 0 ? -1 : 1);
        } else if (Math.random() < 0.02) {
          // Occasional random wander up/down
          cpu.moveZ(Math.random() < 0.5 ? -1 : 1);
        }

        switch (this.state) {
          case 'CHASE': cpu.move(dir); break;
          case 'RETREAT':
            cpu.move(-dir);
            cpu.blocking = Math.random() < 0.6;
            break;
          case 'COUNTER':
            cpu.move(dir * 0.5);
            if (!cpu.attacking && Math.random() < 0.25) {
              const r = Math.random();
              if (r < 0.3) cpu.punch('hook');
              else if (r < 0.6) cpu.punch('cross');
              else cpu.punch('uppercut');
            }
            break;
          case 'PRESSURE':
            cpu.move(dir * 0.3);
            if (!cpu.attacking && Math.random() < 0.12) {
              // Target head when low HP
              if (tHpPct < 0.3 && Math.random() < 0.6) {
                cpu.punch(Math.random() < 0.5 ? 'hook' : 'uppercut');
              }
              // Body shot when target low stamina
              else if (tStaPct < 0.4 && Math.random() < 0.5) {
                cpu.punch('bodyshot');
              } else {
                cpu.punch('jab');
              }
            }
            break;
          case 'ATTACK':
            if (dist > 70) cpu.move(dir * 0.5);
            if (!cpu.attacking) {
              // Attempt combos at higher rounds
              if (this.comboSeq && this.comboStep < this.comboSeq.length) {
                if (Math.random() < 0.15) {
                  cpu.punch(this.comboSeq[this.comboStep]);
                  this.comboStep++;
                }
              } else if (Math.random() < 0.08 + roundNumber * 0.01) {
                // Start a combo or single punch
                const r = Math.random();
                if (r < 0.15 && roundNumber >= 2) {
                  this.comboSeq = ['jab', 'cross', 'hook'];
                  this.comboStep = 0;
                  cpu.punch('jab');
                  this.comboStep = 1;
                } else if (r < 0.35) cpu.punch('jab');
                else if (r < 0.55) cpu.punch('cross');
                else if (r < 0.7) cpu.punch('hook');
                else if (r < 0.82) cpu.punch('uppercut');
                else if (r < 0.9) cpu.punch('bodyshot');
                else {
                  // Feint: fake start without actual punch
                  this.feinting = true;
                  this.feintTimer = 200;
                }
              }
              // Occasional jump attack
              if (Math.random() < 0.003) cpu.jump();
            }
            break;
          case 'IDLE':
            if (Math.random() < 0.03) cpu.move(dir * 0.3);
            cpu.blocking = Math.random() < 0.15 + roundNumber * 0.03;
            if (Math.random() < 0.004) cpu.jump();
            break;
        }
      }
    };

    // ── Particles ──
    function spawnHitParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y, vx: (Math.random() - 0.5) * 6, vy: -Math.random() * 4 - 1,
          life: 0.3 + Math.random() * 0.3, color, size: 2 + Math.random() * 3
        });
      }
    }
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 6 * dt; p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i]; t.y += t.vy; t.life -= dt;
        if (t.life <= 0) floatingTexts.splice(i, 1);
      }
    }
    function drawParticles(ctx) {
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, p.life * 3);
        ctx.fillStyle = p.color;
        ctx.fillRect(Math.round(p.x), Math.round(p.y), Math.round(p.size), Math.round(p.size));
      }
      ctx.globalAlpha = 1;
      // Floating text
      ctx.font = '6px "Press Start 2P"'; ctx.textAlign = 'center';
      for (const t of floatingTexts) {
        ctx.globalAlpha = Math.max(0, t.life);
        ctx.fillStyle = '#000'; ctx.fillText(t.text, t.x + 1, t.y + 1);
        ctx.fillStyle = t.color; ctx.fillText(t.text, t.x, t.y);
      }
      ctx.globalAlpha = 1;
    }

    // ── Hit Detection ──
    function checkHits() { doHitCheck(player, enemy); doHitCheck(enemy, player); }
    function doHitCheck(attacker, victim) {
      // Z-distance check: fighters must be at similar ring depth to connect
      const zDist = Math.abs(attacker.groundY - victim.groundY);
      if (zDist > 25) return; // too far apart vertically in ring
      const hb = attacker.getHitbox();
      if (!hb) return;
      const hr = victim.getHurtbox();
      if (hb.x < hr.x + hr.w && hb.x + hb.w > hr.x && hb.y < hr.y + hr.h && hb.y + hb.h > hr.y) {
        attacker.hitRegistered = true;
        const hitY = hb.y + hb.h / 2;
        const headZone = victim.headY + 5;
        let dmg = attacker.currentPunch.dmg * (attacker.dmgMult || 1);
        let isHead = hitY < headZone && !attacker.currentPunch.bodyShot;
        if (isHead) dmg *= attacker.currentPunch.headMult;

        victim.takeDamage(dmg, attacker.x, attacker.currentPunch, isHead);

        // Crowd reacts to hits
        boostCrowdExcitement(dmg * 0.008 + (isHead ? 0.05 : 0));

        // Combo counter
        if (attacker === lastAttacker && comboTimer > 0) {
          comboCount++;
        } else { comboCount = 1; }
        lastAttacker = attacker; comboTimer = 1.5;
        // Crowd goes wild for combos
        if (comboCount >= 3) boostCrowdExcitement(0.15);
        if (comboCount >= 5) { boostCrowdExcitement(0.3); triggerCrowdWave(); }

        // Screen shake (extra for uppercut)
        let shakeI = dmg * 0.3;
        if (attacker.currentPunch.name === 'UPPERCUT') shakeI *= 1.5;
        triggerShake(shakeI, dmg * 12);

        freezeFrames = Math.floor(dmg * 0.15);

        const px = hb.x + hb.w / 2, py = hb.y + hb.h / 2;
        spawnHitParticles(px, py, isHead ? '#ffff44' : '#ff8844', isHead ? 8 : 4);
        if (isHead && dmg > 15) flashAlpha = 0.3;

        // KO check
        if (victim.hp <= 0) {
          victim.hp = 0;
          // Slow-mo on final hit
          slowMoTimer = 1.0;
          slowMoScale = 0.2;
          gameState = 'KO'; koTimer = 3; koTarget = victim;
          triggerShake(8, 600);
          spawnHitParticles(px, py, '#ffffff', 20);
          cameraFlashTimer = 0.5;
          // Crowd goes absolutely wild on KO
          boostCrowdExcitement(1);
          triggerCrowdWave();
          spawnConfetti(40);
          for (let ti = 0; ti < 5; ti++) spawnThrownItem(60 + Math.random() * 520);
        }
      }
    }

    function triggerShake(intensity, duration) {
      shakeDur = Math.max(shakeDur, duration);
      shakeX = (Math.random() - 0.5) * intensity; shakeY = (Math.random() - 0.5) * intensity;
    }

    // ── Drawing ──
    function drawRing(ctx) {
      // Floor
      ctx.fillStyle = C.floor;
      ctx.fillRect(RING.x - 10, RING.y + RING.h - 8, RING.w + 20, 50);
      ctx.strokeStyle = C.floorLine; ctx.lineWidth = 1;
      for (let i = 0; i < 12; i++) {
        const lx = RING.x + i * (RING.w / 11);
        ctx.beginPath(); ctx.moveTo(lx, RING.y + RING.h - 8); ctx.lineTo(lx + (i < 6 ? -15 : 15), RING.y + RING.h + 40); ctx.stroke();
      }

      // Ring mat with subtle texture
      ctx.fillStyle = C.ring;
      ctx.fillRect(RING.x, RING.y, RING.w, RING.h);
      // Texture dots
      ctx.fillStyle = '#352040';
      for (let tx = RING.x + 10; tx < RING.x + RING.w; tx += 20) {
        for (let ty = RING.y + 10; ty < RING.y + RING.h; ty += 20) {
          if (Math.sin(tx * ty * 0.1) > 0.5) ctx.fillRect(tx, ty, 2, 2);
        }
      }

      // Center logo (pixel "K.O.")
      ctx.fillStyle = '#3a2248'; ctx.font = '14px "Press Start 2P"'; ctx.textAlign = 'center';
      ctx.globalAlpha = 0.15;
      ctx.fillText('K.O.', RING_CENTER_X, RING.y + RING.h / 2 + 5);
      ctx.globalAlpha = 1;

      // Center line
      ctx.strokeStyle = '#4a3050'; ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      ctx.beginPath(); ctx.moveTo(RING_CENTER_X, RING.y + 10); ctx.lineTo(RING_CENTER_X, RING.y + RING.h - 10); ctx.stroke();
      ctx.setLineDash([]);

      // Posts
      const posts = [[RING.x, RING.y], [RING.x + RING.w, RING.y], [RING.x, RING.y + RING.h], [RING.x + RING.w, RING.y + RING.h]];
      for (const [px, py] of posts) {
        ctx.fillStyle = C.post; ctx.fillRect(px - 5, py - 8, 10, 16);
        ctx.fillStyle = '#aa8844'; ctx.fillRect(px - 4, py - 6, 8, 4);
      }

      // Ropes with elastic deformation + vibration
      ropeVibrationL *= 0.92; ropeVibrationR *= 0.92;
      for (let r = 0; r < 3; r++) {
        const ry = RING.y + 15 + r * 28;
        let lbx = 0, lby = 0, rbx = 0, rby = 0;
        const RZ = 35;
        [player, enemy].forEach(b => {
          if (!b) return;
          const ld = b.x - RING.x;
          if (ld < RZ) { const t = Math.max(0, 1 - ld / RZ); lbx = Math.min(lbx, -t * 18); lby = Math.max(lby, t * 4); }
          const rd = (RING.x + RING.w) - b.x;
          if (rd < RZ) { const t = Math.max(0, 1 - rd / RZ); rbx = Math.max(rbx, t * 18); rby = Math.max(rby, t * 4); }
        });
        // Add vibration
        const vibL = Math.sin(performance.now() * 0.03 + r) * ropeVibrationL;
        const vibR = Math.sin(performance.now() * 0.03 + r + 1) * ropeVibrationR;

        // Shadow
        ctx.strokeStyle = C.ropeShadow; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(RING.x + lbx, ry + 2 + lby + vibL);
        ctx.quadraticCurveTo(RING.x + RING.w / 2, ry + 2, RING.x + RING.w + rbx, ry + 2 + rby + vibR); ctx.stroke();
        // Main
        ctx.strokeStyle = C.ropes; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.moveTo(RING.x + lbx, ry + lby + vibL);
        ctx.quadraticCurveTo(RING.x + RING.w / 2, ry, RING.x + RING.w + rbx, ry + rby + vibR); ctx.stroke();
      }

      // Spotlight glow
      const grd = ctx.createRadialGradient(RING_CENTER_X, RING.y - 20, 10, RING_CENTER_X, RING.y + RING.h / 2, 300);
      grd.addColorStop(0, 'rgba(255,240,200,0.06)');
      grd.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(RING.x - 20, RING.y - 40, RING.w + 40, RING.h + 60);
    }

    // ── Crowd Excitement System ──
    let crowdExcitement = 0;       // 0 = calm, 1 = max hype
    let crowdExcitementTarget = 0;
    let crowdConfetti = [];        // confetti particles
    let crowdThrownItems = [];     // thrown cups/hats
    let crowdSigns = [];           // held-up signs
    let crowdWavePhase = -1;       // -1 = no wave, 0+ = wave progressing
    let lastCrowdUpdate = 0;

    function boostCrowdExcitement(amount) {
      crowdExcitementTarget = Math.min(1, crowdExcitementTarget + amount);
    }

    function triggerCrowdWave() {
      crowdWavePhase = 0;
    }

    function spawnConfetti(count) {
      for (let i = 0; i < count; i++) {
        crowdConfetti.push({
          x: Math.random() * W, y: -10 - Math.random() * 50,
          vx: (Math.random() - 0.5) * 2, vy: 0.5 + Math.random() * 1.5,
          rot: Math.random() * Math.PI * 2, rotV: (Math.random() - 0.5) * 0.2,
          color: ['#ff4444', '#44ff44', '#4444ff', '#ffdd44', '#ff44ff', '#44ffff', '#ffffff', '#ff8844'][Math.floor(Math.random() * 8)],
          size: 2 + Math.random() * 4, life: 3 + Math.random() * 3
        });
      }
    }

    function spawnThrownItem(fromX) {
      const types = ['🍺', '🎩', '🍿', '📱', '👟', '🧢'];
      crowdThrownItems.push({
        x: fromX, y: 155,
        vx: (Math.random() - 0.5) * 4 + (RING_CENTER_X - fromX) * 0.01,
        vy: -3 - Math.random() * 3,
        text: types[Math.floor(Math.random() * types.length)],
        life: 2.5, rot: 0, rotV: (Math.random() - 0.5) * 0.3
      });
    }

    function drawAudience(ctx) {
      const now = performance.now();
      const dt_crowd = Math.min(0.05, (now - lastCrowdUpdate) / 1000);
      lastCrowdUpdate = now;

      // Update excitement (smooth lerp toward target, slow decay)
      crowdExcitement += (crowdExcitementTarget - crowdExcitement) * 0.05;
      crowdExcitementTarget = Math.max(0, crowdExcitementTarget - 0.003);

      // Fight-state reactive excitement
      if (player && enemy) {
        const lowestHp = Math.min(player.hp / player.maxHp, enemy.hp / enemy.maxHp);
        if (lowestHp < 0.2) crowdExcitementTarget = Math.max(crowdExcitementTarget, 0.6);
        if (gameState === 'KO') crowdExcitementTarget = 1;
      }

      const exc = crowdExcitement;

      // ── Audience noise visualization bars at top ──
      if (exc > 0.1) {
        ctx.globalAlpha = exc * 0.15;
        const barCount = 30;
        for (let i = 0; i < barCount; i++) {
          const bx = (W / barCount) * i;
          const bh = Math.abs(Math.sin(now * 0.004 + i * 0.7)) * exc * 20 + 2;
          ctx.fillStyle = exc > 0.7 ? '#ff4444' : exc > 0.4 ? '#ffaa44' : '#44aaff';
          ctx.fillRect(bx, 0, W / barCount - 1, bh);
        }
        ctx.globalAlpha = 1;
      }

      // ── Back row (3rd row — farthest, darkest) ──
      ctx.fillStyle = '#050310';
      ctx.fillRect(0, 68, W, 25);
      const farBackHeads = [30, 65, 100, 135, 170, 205, 240, 280, 320, 355, 390, 425, 460, 500, 540, 575, 610];
      for (let i = 0; i < farBackHeads.length; i++) {
        const hx = farBackHeads[i];
        const waveBob = crowdWavePhase >= 0 ? Math.max(0, Math.sin((crowdWavePhase - hx / W * 4) * Math.PI)) * 6 : 0;
        const excBob = Math.sin(now * 0.003 + i * 1.3) * exc * 3;
        const hy = 82 + Math.sin(hx * 0.4 + now * 0.0008) * 1 - waveBob - excBob;
        ctx.fillStyle = '#0a0616';
        ctx.beginPath(); ctx.arc(hx, hy, 6, 0, Math.PI * 2); ctx.fill();
        ctx.fillRect(hx - 5, hy + 4, 10, 8);
      }

      // ── Middle row (2nd row) ──
      ctx.fillStyle = '#080412';
      ctx.fillRect(0, 88, W, 38);
      const backHeads = [40, 85, 130, 175, 220, 270, 320, 365, 410, 455, 500, 545, 590, 630];
      const backColors = ['#0e0820', '#100a22', '#0c0719', '#110b24', '#0d0818'];
      for (let i = 0; i < backHeads.length; i++) {
        const hx = backHeads[i];
        const waveBob = crowdWavePhase >= 0 ? Math.max(0, Math.sin((crowdWavePhase - hx / W * 4) * Math.PI)) * 10 : 0;
        const excJump = exc > 0.7 && Math.sin(now * 0.006 + i * 2) > 0.5 ? 5 : 0;
        const excBob = Math.sin(now * 0.004 + i * 1.7) * exc * 4;
        const hy = 115 + Math.sin(hx * 0.3 + now * 0.001) * 2 - waveBob - excJump - excBob;
        ctx.fillStyle = backColors[i % backColors.length];
        ctx.beginPath(); ctx.arc(hx, hy, 8, 0, Math.PI * 2); ctx.fill();
        ctx.fillRect(hx - 6, hy + 5, 12, 10);

        // Arms raised when excited
        if (exc > 0.3 && (i + Math.floor(now / 600)) % 3 === 0) {
          ctx.strokeStyle = backColors[i % backColors.length]; ctx.lineWidth = 2;
          const armOff = Math.sin(now * 0.007 + i) * 6;
          ctx.beginPath(); ctx.moveTo(hx - 5, hy + 3); ctx.lineTo(hx - 10, hy - 8 + armOff); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(hx + 5, hy + 3); ctx.lineTo(hx + 10, hy - 8 - armOff); ctx.stroke();
        }

        // Phone flashlights (some spectators hold up phones)
        if (exc > 0.5 && i % 4 === Math.floor(now / 2000) % 4) {
          ctx.fillStyle = `rgba(200,220,255,${0.3 + Math.sin(now * 0.01 + i) * 0.2})`;
          ctx.fillRect(hx - 1, hy - 12, 3, 5);
          // Screen glow
          ctx.fillStyle = `rgba(180,200,255,${0.1 * exc})`;
          ctx.beginPath(); ctx.arc(hx, hy - 12, 8, 0, Math.PI * 2); ctx.fill();
        }
      }

      // ── Front row (closest, most detail) ──
      ctx.fillStyle = '#0d0818';
      ctx.fillRect(0, 120, W, 55);
      const frontHeads = [60, 100, 145, 190, 230, 280, 330, 370, 420, 460, 510, 550, 590];
      const crowdColors = ['#1a0f28', '#1e1230', '#16102a', '#201438', '#1a1028'];
      const shirtColors = ['#2a1535', '#221040', '#2d1838', '#1e1530', '#261242'];
      for (let i = 0; i < frontHeads.length; i++) {
        const hx = frontHeads[i];
        const waveBob = crowdWavePhase >= 0 ? Math.max(0, Math.sin((crowdWavePhase - hx / W * 4) * Math.PI)) * 14 : 0;
        const excJump = exc > 0.5 && Math.sin(now * 0.008 + i * 1.5) > 0.3 ? exc * 8 : 0;
        const excBob = Math.sin(now * 0.005 + i * 2.1) * exc * 5;
        const hy = 148 + Math.sin(hx * 0.5 + now * 0.002) * 3 - waveBob - excJump - excBob;

        // Body/shirt
        ctx.fillStyle = shirtColors[i % shirtColors.length];
        ctx.fillRect(hx - 8, hy + 6, 16, 18);

        // Head
        ctx.fillStyle = crowdColors[i % crowdColors.length];
        ctx.beginPath(); ctx.arc(hx, hy, 10, 0, Math.PI * 2); ctx.fill();

        // Facial feature dot (mouth opening when excited)
        if (exc > 0.4) {
          ctx.fillStyle = '#0a0510';
          ctx.beginPath(); ctx.arc(hx, hy + 3, 1.5 + exc * 2, 0, Math.PI * 2); ctx.fill();
        }

        // Waving arms — more arms wave when more excited
        const armWaveChance = exc > 0.6 ? 0.7 : exc > 0.3 ? 0.4 : (i % 3 === Math.floor(now / 800) % 3 ? 1 : 0);
        if (Math.sin(now * 0.001 + i * 3) > (1 - armWaveChance)) {
          ctx.strokeStyle = crowdColors[i % crowdColors.length]; ctx.lineWidth = 2.5;
          const la = Math.sin(now * 0.008 + i) * (0.3 + exc * 0.5);
          const ra = Math.sin(now * 0.009 + i + 2) * (0.3 + exc * 0.5);
          // Left arm
          ctx.beginPath();
          ctx.moveTo(hx - 8, hy + 6);
          ctx.lineTo(hx - 16, hy - 8 + la * 20);
          ctx.stroke();
          // Right arm
          ctx.beginPath();
          ctx.moveTo(hx + 8, hy + 6);
          ctx.lineTo(hx + 16, hy - 8 + ra * 20);
          ctx.stroke();
        }

        // Held-up signs (some spectators at high excitement)
        if (exc > 0.65 && i % 5 === 2) {
          ctx.save();
          const signBob = Math.sin(now * 0.004 + i) * 3;
          const signY = hy - 22 + signBob;
          // Sign background
          ctx.fillStyle = ['#ffffff', '#ffdd44', '#ff4444', '#44ff44'][i % 4];
          ctx.fillRect(hx - 14, signY - 8, 28, 12);
          // Sign text
          ctx.fillStyle = '#000'; ctx.font = '4px "Press Start 2P"'; ctx.textAlign = 'center';
          const signTexts = ['KO!', 'GO!!', 'WOW', 'FIGHT', 'HIT!', 'YES!', 'BOOM', 'NICE'];
          ctx.fillText(signTexts[(i + Math.floor(now / 3000)) % signTexts.length], hx, signY);
          // Sign stick
          ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(hx, signY + 4); ctx.lineTo(hx, hy - 2); ctx.stroke();
          ctx.restore();
        }

        // Phone flashlights (front row)
        if (exc > 0.4 && (i + 2) % 5 === Math.floor(now / 1500) % 5) {
          const phoneY = hy - 14;
          ctx.fillStyle = '#445'; ctx.fillRect(hx + 6, phoneY, 4, 7); // phone body
          ctx.fillStyle = `rgba(180,200,255,${0.5 + Math.sin(now * 0.008 + i * 2) * 0.3})`;
          ctx.fillRect(hx + 6, phoneY, 4, 7); // screen glow
          // Light beam
          ctx.fillStyle = `rgba(200,220,255,${0.05 * exc})`;
          ctx.beginPath();
          ctx.moveTo(hx + 8, phoneY);
          ctx.lineTo(hx + 2, phoneY - 20);
          ctx.lineTo(hx + 14, phoneY - 20);
          ctx.closePath(); ctx.fill();
        }
      }

      // ── Camera flashes (more frequent when more exciting) ──
      const flashChance = 0.003 + exc * 0.04;
      const flashCount = cameraFlashTimer > 0 ? 3 : (Math.random() < flashChance ? 1 : 0);
      for (let fi = 0; fi < flashCount; fi++) {
        const allHeads = [...frontHeads, ...backHeads];
        const fx = allHeads[Math.floor(Math.random() * allHeads.length)];
        const fy = 110 + Math.random() * 50;
        // Bright flash
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.beginPath(); ctx.arc(fx, fy, 3, 0, Math.PI * 2); ctx.fill();
        // Glow
        ctx.fillStyle = 'rgba(255,255,200,0.2)';
        ctx.beginPath(); ctx.arc(fx, fy, 15, 0, Math.PI * 2); ctx.fill();
        // Lens flare streak
        ctx.strokeStyle = 'rgba(255,255,200,0.15)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(fx - 20, fy); ctx.lineTo(fx + 20, fy); ctx.stroke();
      }

      // ── Crowd wave animation ──
      if (crowdWavePhase >= 0) {
        crowdWavePhase += dt_crowd * 2;
        if (crowdWavePhase > 6) crowdWavePhase = -1; // wave complete
      }
      // Trigger wave at high excitement randomly
      if (exc > 0.6 && crowdWavePhase < 0 && Math.random() < 0.001) {
        triggerCrowdWave();
      }

      // ── Thrown items ──
      // Spawn thrown items on big moments
      if (exc > 0.8 && Math.random() < 0.005) {
        spawnThrownItem(frontHeads[Math.floor(Math.random() * frontHeads.length)]);
      }
      // Update and draw thrown items
      for (let i = crowdThrownItems.length - 1; i >= 0; i--) {
        const item = crowdThrownItems[i];
        item.x += item.vx; item.y += item.vy; item.vy += 0.15;
        item.rot += item.rotV; item.life -= dt_crowd;
        if (item.life <= 0 || item.y > H) { crowdThrownItems.splice(i, 1); continue; }
        ctx.save();
        ctx.translate(item.x, item.y);
        ctx.rotate(item.rot);
        ctx.globalAlpha = Math.min(1, item.life);
        ctx.font = '8px serif'; ctx.textAlign = 'center';
        ctx.fillText(item.text, 0, 0);
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      // ── Confetti ──
      if (gameState === 'KO' && crowdConfetti.length < 50) {
        spawnConfetti(3);
      }
      for (let i = crowdConfetti.length - 1; i >= 0; i--) {
        const c = crowdConfetti[i];
        c.x += c.vx + Math.sin(now * 0.003 + i) * 0.5;
        c.y += c.vy;
        c.rot += c.rotV;
        c.life -= dt_crowd;
        if (c.life <= 0 || c.y > H) { crowdConfetti.splice(i, 1); continue; }
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.rotate(c.rot);
        ctx.globalAlpha = Math.min(1, c.life * 0.5);
        ctx.fillStyle = c.color;
        ctx.fillRect(-c.size / 2, -c.size / 4, c.size, c.size / 2);
        ctx.globalAlpha = 1;
        ctx.restore();
      }
      // Clear confetti when game resets
      if (gameState === 'FIGHTING' && crowdConfetti.length > 0 && crowdConfetti.length < 5) {
        crowdConfetti = [];
      }

      // ── Spotlight sweeps at high excitement ──
      if (exc > 0.5) {
        ctx.globalAlpha = exc * 0.04;
        const spotX1 = W * 0.3 + Math.sin(now * 0.001) * W * 0.2;
        const spotX2 = W * 0.7 + Math.cos(now * 0.0013) * W * 0.2;
        const spotGrd1 = ctx.createRadialGradient(spotX1, 60, 5, spotX1, 60, 120);
        spotGrd1.addColorStop(0, 'rgba(255,200,100,1)');
        spotGrd1.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = spotGrd1;
        ctx.fillRect(spotX1 - 120, 0, 240, 175);
        const spotGrd2 = ctx.createRadialGradient(spotX2, 60, 5, spotX2, 60, 120);
        spotGrd2.addColorStop(0, 'rgba(100,100,255,1)');
        spotGrd2.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = spotGrd2;
        ctx.fillRect(spotX2 - 120, 0, 240, 175);
        ctx.globalAlpha = 1;
      }

      // ── Crowd stomp/clap rhythm lines ──
      if (exc > 0.4) {
        const rhythm = Math.sin(now * 0.01) > 0.7;
        if (rhythm) {
          ctx.globalAlpha = exc * 0.08;
          ctx.fillStyle = '#fff';
          ctx.fillRect(0, 170, W, 2);
          ctx.globalAlpha = 1;
        }
      }
    }

    function drawHUD(ctx) {
      const barW = 180, barH = 14, margin = 20;
      drawBar(ctx, margin, 20, barW, barH, player.hp, player.maxHp, hpColor(player.hp, player.maxHp), 'left');
      drawBar(ctx, margin, 38, barW * 0.6, 8, player.stamina, player.maxStamina, C.stamina, 'left');
      drawName(ctx, margin, 56, player.name, C.p1, 'left');
      const p2x = W - margin;
      drawBar(ctx, p2x, 20, barW, barH, enemy.hp, enemy.maxHp, hpColor(enemy.hp, enemy.maxHp), 'right');
      drawBar(ctx, p2x, 38, barW * 0.6, 8, enemy.stamina, enemy.maxStamina, C.stamina, 'right');
      drawName(ctx, p2x, 56, enemy.name, C.p2, 'right');

      ctx.fillStyle = C.gold; ctx.font = '10px "Press Start 2P"'; ctx.textAlign = 'center';
      ctx.fillText('ROUND ' + roundNumber, W / 2, 20);
      ctx.font = '20px "Press Start 2P"';
      ctx.fillText(Math.ceil(roundTimer).toString(), W / 2, 46);

      ctx.font = '8px "Press Start 2P"';
      ctx.fillStyle = C.p1; ctx.textAlign = 'left'; ctx.fillText(player.score.toString(), margin, 76);
      ctx.fillStyle = C.p2; ctx.textAlign = 'right'; ctx.fillText(enemy.score.toString(), W - margin, 76);

      // Combo counter
      if (comboCount >= 2 && comboTimer > 0) {
        ctx.textAlign = 'center';
        ctx.fillStyle = comboCount >= 5 ? '#ff4444' : comboCount >= 3 ? '#ffaa44' : '#ffdd44';
        ctx.font = '12px "Press Start 2P"';
        const cx = lastAttacker === player ? margin + 90 : W - margin - 90;
        ctx.globalAlpha = Math.min(1, comboTimer);
        ctx.fillText(comboCount + ' HIT COMBO!', cx, 90);
        ctx.globalAlpha = 1;
      }
    }

    function drawBar(ctx, x, y, w, h, val, max, color, align) {
      const bx = align === 'right' ? x - w : x, pct = Math.max(0, val / max);
      ctx.fillStyle = '#1a1a1a'; ctx.fillRect(bx, y, w, h);
      ctx.fillStyle = color;
      if (align === 'right') ctx.fillRect(bx + w * (1 - pct), y, w * pct, h);
      else ctx.fillRect(bx, y, w * pct, h);
      ctx.strokeStyle = '#555'; ctx.lineWidth = 1; ctx.strokeRect(bx, y, w, h);
    }
    function drawName(ctx, x, y, name, color, align) {
      ctx.font = '8px "Press Start 2P"'; ctx.fillStyle = color; ctx.textAlign = align; ctx.fillText(name, x, y);
    }
    function hpColor(hp, max) { const p = hp / max; return p > 0.5 ? C.hpGreen : p > 0.25 ? C.hpYellow : C.hpRed; }

    function drawVignette(ctx) {
      const grd = ctx.createRadialGradient(W / 2, H / 2, 100, W / 2, H / 2, 380);
      grd.addColorStop(0, 'rgba(0,0,0,0)');
      grd.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);
    }

    function drawTitle(ctx) {
      ctx.fillStyle = C.bg; ctx.fillRect(0, 0, W, H);
      drawAudience(ctx); drawRing(ctx);
      ctx.textAlign = 'center';
      ctx.fillStyle = C.textShadow; ctx.font = '28px "Press Start 2P"';
      ctx.fillText('KNOCKOUT!', W / 2 + 2, 100 + 2);
      ctx.fillStyle = C.gold; ctx.fillText('KNOCKOUT!', W / 2, 100);
      ctx.fillStyle = C.ropes; ctx.font = '10px "Press Start 2P"';
      ctx.fillText('RETRO BOXING', W / 2, 130);
      // Party overlay handles the menu — show it
      if (!showPartyMenu) {
        document.getElementById('party-overlay').style.display = 'flex';
        document.getElementById('party-menu').style.display = 'flex';
        document.getElementById('waiting-screen').style.display = 'none';
        showPartyMenu = true;
      }
      ctx.fillStyle = '#666'; ctx.font = '6px "Press Start 2P"';
      ctx.fillText('WASD MOVE  LMB/ERQF PUNCH  S BLOCK  SPACE JUMP', W / 2, 340);
      drawVignette(ctx);
    }

    // ── Character Selection Screen ──
    function drawCharSelect(ctx) {
      ctx.fillStyle = C.bg; ctx.fillRect(0, 0, W, H);
      drawAudience(ctx);

      const now = performance.now();

      // Title
      ctx.textAlign = 'center';
      ctx.fillStyle = C.gold; ctx.font = '16px "Press Start 2P"';
      ctx.fillText('SELECT YOUR FIGHTER', W / 2, 40);

      const cardW = 180, cardH = 280, gap = 15;
      const totalW = CHARACTERS.length * cardW + (CHARACTERS.length - 1) * gap;
      const startX = (W - totalW) / 2;

      for (let i = 0; i < CHARACTERS.length; i++) {
        const ch = CHARACTERS[i];
        const cx = startX + i * (cardW + gap);
        const cy = 55;
        const isSelected = i === selectedCharIdx;
        const isHover = charHoverIdx === i;

        // Card background
        ctx.fillStyle = isSelected ? 'rgba(255,220,68,0.15)' : 'rgba(20,10,35,0.85)';
        ctx.fillRect(cx, cy, cardW, cardH);

        // Card border (animated glow for selected)
        if (isSelected) {
          ctx.strokeStyle = C.gold; ctx.lineWidth = 3;
          ctx.shadowColor = C.gold; ctx.shadowBlur = 10 + Math.sin(now * 0.005) * 5;
        } else if (isHover) {
          ctx.strokeStyle = '#888'; ctx.lineWidth = 2; ctx.shadowBlur = 0;
        } else {
          ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.shadowBlur = 0;
        }
        ctx.strokeRect(cx, cy, cardW, cardH);
        ctx.shadowBlur = 0;

        // Character name
        ctx.fillStyle = isSelected ? C.gold : ch.colors.main;
        ctx.font = '12px "Press Start 2P"'; ctx.textAlign = 'center';
        ctx.fillText(ch.name, cx + cardW / 2, cy + 22);

        // Title
        ctx.fillStyle = '#888'; ctx.font = '5px "Press Start 2P"';
        ctx.fillText(ch.title, cx + cardW / 2, cy + 34);

        // Character preview (silhouette/body)
        const previewX = cx + cardW / 2;
        const previewY = cy + 130;
        const sc = ch.bodyScale;

        ctx.save();
        ctx.translate(previewX, previewY);

        // Idle bobbing
        const bob = Math.sin(now * 0.004 + i * 2) * 2;

        // Legs
        ctx.strokeStyle = ch.colors.skin; ctx.lineWidth = ch.legThick;
        ctx.beginPath(); ctx.moveTo(-8 * sc, 0); ctx.lineTo(-10 * sc, 30 * sc); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(8 * sc, 0); ctx.lineTo(10 * sc, 30 * sc); ctx.stroke();

        // Boots
        ctx.fillStyle = ch.colors.shoe;
        ctx.fillRect(-14 * sc, 26 * sc, 8 * sc, 8 * sc);
        ctx.fillRect(6 * sc, 26 * sc, 8 * sc, 8 * sc);

        // Shorts
        ctx.fillStyle = ch.colors.main;
        ctx.fillRect(-12 * sc, -5, 24 * sc, 14 * sc);
        ctx.fillStyle = ch.colors.trim;
        ctx.fillRect(-12 * sc, 7 * sc, 24 * sc, 3);

        // Torso
        ctx.fillStyle = ch.colors.skin;
        ctx.beginPath();
        ctx.moveTo(-12 * sc, -5 + bob); ctx.lineTo(12 * sc, -5 + bob);
        ctx.lineTo(14 * sc, -30 * sc + bob); ctx.lineTo(-14 * sc, -30 * sc + bob);
        ctx.closePath(); ctx.fill();

        // Shoulder caps
        ctx.fillStyle = ch.colors.skinShd;
        ctx.beginPath(); ctx.arc(-14 * sc, -28 * sc + bob, 5 * sc, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(14 * sc, -28 * sc + bob, 5 * sc, 0, Math.PI * 2); ctx.fill();

        // Arms (guard position, animated)
        const guardBob = Math.sin(now * 0.006 + i) * 3;
        ctx.strokeStyle = ch.colors.skin; ctx.lineWidth = ch.armThick;
        // Left arm
        ctx.beginPath(); ctx.moveTo(-14 * sc, -26 * sc + bob);
        ctx.lineTo(-18 * sc, -15 * sc + bob + guardBob); ctx.stroke();
        // Right arm
        ctx.beginPath(); ctx.moveTo(14 * sc, -26 * sc + bob);
        ctx.lineTo(18 * sc, -15 * sc + bob - guardBob); ctx.stroke();

        // Gloves
        ctx.fillStyle = ch.colors.glove;
        ctx.beginPath(); ctx.arc(-18 * sc, -15 * sc + bob + guardBob, 7 * sc, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(18 * sc, -15 * sc + bob - guardBob, 7 * sc, 0, Math.PI * 2); ctx.fill();

        // Head
        const headR = 12 * ch.headSize * sc;
        const headY = -35 * sc + bob;
        ctx.fillStyle = ch.colors.skin;
        ctx.beginPath(); ctx.arc(0, headY, headR, 0, Math.PI * 2); ctx.fill();

        // Hair style
        ctx.fillStyle = ch.colors.hair;
        if (ch.hairStyle === 'mohawk') {
          // Spiky mohawk
          for (let s = -3; s <= 3; s++) {
            ctx.beginPath();
            ctx.moveTo(s * 2.5, headY - headR + 2);
            ctx.lineTo(s * 1.5, headY - headR - 8);
            ctx.lineTo(s * 2.5 + 2, headY - headR + 2);
            ctx.fill();
          }
        } else if (ch.hairStyle === 'bald') {
          // Bald — just a shine
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.beginPath(); ctx.arc(-2, headY - headR * 0.5, headR * 0.4, 0, Math.PI * 2); ctx.fill();
        } else {
          // Short cropped
          ctx.beginPath();
          ctx.arc(0, headY - 2, headR + 1, Math.PI, 0); ctx.fill();
        }

        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(-4, headY - 1, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, headY - 1, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#111';
        ctx.beginPath(); ctx.arc(-3.5, headY - 0.5, 1.2, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(4.5, headY - 0.5, 1.2, 0, Math.PI * 2); ctx.fill();

        ctx.restore();

        // Description
        ctx.fillStyle = '#aaa'; ctx.font = '5px "Press Start 2P"'; ctx.textAlign = 'center';
        ctx.fillText(ch.desc, cx + cardW / 2, cy + 200);

        // Stat bars
        const statNames = Object.keys(ch.statBars);
        const barStartY = cy + 215;
        for (let s = 0; s < statNames.length; s++) {
          const sn = statNames[s];
          const sv = ch.statBars[sn];
          const sy = barStartY + s * 12;

          ctx.fillStyle = '#666'; ctx.font = '5px "Press Start 2P"'; ctx.textAlign = 'left';
          ctx.fillText(sn, cx + 10, sy + 4);

          // Stat bar background
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(cx + 45, sy - 2, 120, 8);

          // Stat bar fill
          const barColors = { 1: '#ff4444', 2: '#ff8844', 3: '#ffdd44', 4: '#88dd44', 5: '#44ff44' };
          ctx.fillStyle = barColors[sv] || '#888';
          ctx.fillRect(cx + 45, sy - 2, (sv / 5) * 120, 8);
        }
      }

      // Instructions
      ctx.fillStyle = '#666'; ctx.font = '6px "Press Start 2P"'; ctx.textAlign = 'center';
      ctx.fillText('CLICK TO SELECT  •  PRESS SPACE OR CLICK START TO FIGHT', W / 2, H - 20);

      // Start button
      const btnW = 160, btnH = 24;
      const btnX = W / 2 - btnW / 2, btnY = H - 55;
      ctx.fillStyle = CHARACTERS[selectedCharIdx].colors.main;
      ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.strokeStyle = C.gold; ctx.lineWidth = 2;
      ctx.strokeRect(btnX, btnY, btnW, btnH);
      ctx.fillStyle = '#000'; ctx.font = '8px "Press Start 2P"'; ctx.textAlign = 'center';
      ctx.fillText('START FIGHT', W / 2, btnY + 16);

      // Store button region for click detection
      charSelectBtnRegion = { x: btnX, y: btnY, w: btnW, h: btnH };

      drawVignette(ctx);
    }

    // Click regions for character select
    let charHoverIdx = -1;
    let charSelectBtnRegion = null;

    function drawKO(ctx) {
      ctx.textAlign = 'center';
      ctx.fillStyle = '#000a'; ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = C.hpRed; ctx.font = '32px "Press Start 2P"';
      ctx.fillText('K.O.!', W / 2, H / 2 - 20);
      const winner = koTarget === enemy ? player.name : enemy.name;
      ctx.fillStyle = C.gold; ctx.font = '12px "Press Start 2P"';
      ctx.fillText(winner + ' WINS THE ROUND!', W / 2, H / 2 + 20);

      // Victory animation (winner bobs)
      victoryTimer += 0.05;
      const wBox = koTarget === enemy ? player : enemy;
      if (wBox) {
        const vy = Math.abs(Math.sin(victoryTimer * 3)) * 5;
        ctx.save();
        ctx.translate(wBox.x, wBox.y - vy);
        ctx.fillStyle = C.gold; ctx.font = '6px "Press Start 2P"'; ctx.textAlign = 'center';
        ctx.fillText('WINNER', 0, -65);
        ctx.restore();
      }

      if (koTimer <= 0) {
        ctx.fillStyle = C.white; ctx.font = '8px "Press Start 2P"'; ctx.textAlign = 'center';
        ctx.fillText('PRESS SPACE FOR NEXT ROUND', W / 2, H / 2 + 60);
      }
    }

    // ── Main Loop ──
    let lastTime = 0;
    function gameLoop(timestamp) {
      requestAnimationFrame(gameLoop);
      let dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      lastTime = timestamp;

      // Slow-mo
      if (slowMoTimer > 0) { slowMoTimer -= dt; dt *= slowMoScale; slowMoScale = Math.min(1, slowMoScale + 0.01); }

      if (gameState === 'TITLE') {
        drawTitle(ctx);
        return;
      }

      if (gameState === 'CHARSELECT') {
        drawCharSelect(ctx);
        return;
      }

      if (gameState === 'DISCONNECTED') {
        drawTitle(ctx);
        return;
      }

      if (freezeFrames > 0) { freezeFrames--; return; }

      // Camera flash decay
      if (cameraFlashTimer > 0) cameraFlashTimer -= dt;

      if (gameState === 'FIGHTING') {
        roundTimerAccum += dt;
        if (roundTimerAccum >= 1) { roundTimer--; roundTimerAccum -= 1; }
        if (roundTimer <= 0) {
          gameState = 'KO'; koTimer = 2;
          koTarget = player.hp >= enemy.hp ? enemy : player;
          slowMoTimer = 0.5; slowMoScale = 0.3;
        }

        // Combo timer decay
        if (comboTimer > 0) comboTimer -= dt;
        else comboCount = 0;

        // Player mouse aim → aimY based on mouse position relative to player head
        const playerScreenY = player.headY;
        player.aimY = Math.max(-1, Math.min(1, (mouseY - playerScreenY) / 40));

        // Compute mouse aim angle for arm pointing (from shoulder to mouse)
        const shoulderScreenX = player.x + player.facing * 8;
        const shoulderScreenY = player.y - 32 + Math.sin(player.bobPhase) * 2 + player.breathAnim;
        player.mouseAimAngle = Math.atan2(mouseY - shoulderScreenY, mouseX - shoulderScreenX);

        // Player input
        player.blocking = false;
        if (keys['KeyA'] || keys['ArrowLeft']) player.move(-1);
        if (keys['KeyD'] || keys['ArrowRight']) player.move(1);
        if (keys['KeyW'] || keys['ArrowUp']) player.moveZ(-1);  // move up in ring
        if (keys['KeyS'] || keys['ArrowDown'] || rmbDown) {
          player.blocking = true;
          if (!player._blockStarted) { player.blockStartTime = performance.now(); player._blockStarted = true; }
        } else { player._blockStarted = false; }
        if (keys['Space']) { player.jump(); keys['Space'] = false; }

        // Dash punch: double-tap direction + LMB
        if (dashPunchReady && mouseDown) {
          player.punch('dashpunch');
          dashPunchReady = false; mouseDown = false;
        } else {
          if (mouseDown) { player.punch('jab'); mouseDown = false; }
        }
        if (keys['KeyE']) { player.punch('cross'); keys['KeyE'] = false; }
        if (keys['KeyR']) { player.punch('hook'); keys['KeyR'] = false; }
        if (keys['KeyF']) { player.punch('uppercut'); keys['KeyF'] = false; }
        if (keys['KeyQ']) { player.punch('bodyshot'); keys['KeyQ'] = false; }
        // Reset dash if no direction held
        if (!keys['KeyA'] && !keys['KeyD']) dashPunchReady = false;

        // Online guest: send input only, skip local sim
        if (isOnlineMode && !PM.isHost) {
          const inp = {
            left: keys['KeyA'] || keys['ArrowLeft'] ? 1 : 0,
            right: keys['KeyD'] || keys['ArrowRight'] ? 1 : 0,
            block: keys['KeyW'] || keys['ArrowUp'] ? 1 : 0,
            aimY: player.aimY,
            ac: Object.assign({}, guestActionCounts)
          };
          PM.sendInput(inp);
          if (remoteGameState) applyReceivedGameState(remoteGameState);
          updateParticles(dt);
        } else {
          // Host or CPU mode
          if (isOnlineMode && PM.isHost) {
            applyGuestInput(enemy, PM.lastGuestInput);
          } else {
            AI.update(dt, enemy, player);
          }
          player.facing = enemy.x > player.x ? 1 : -1;
          enemy.facing = player.x > enemy.x ? 1 : -1;
          player.update(dt); enemy.update(dt);
          checkHits();
          updateParticles(dt);
          // Host: sync state to guest
          if (isOnlineMode && PM.isHost) {
            syncCounter++;
            if (syncCounter >= SYNC_RATE) {
              PM.sendGameState(serializeGameState());
              syncCounter = 0;
            }
          }
        }
      }

      if (gameState === 'KO') {
        koTimer -= dt;
        updateParticles(dt);
        if (koTimer <= 0 && keys['Space']) {
          const winner = koTarget === enemy ? player : enemy;
          winner.score++; roundNumber++; resetRound();
          keys['Space'] = false;
        }
      }

      // Screen shake
      if (shakeDur > 0) {
        shakeDur -= dt * 1000;
        shakeX = (Math.random() - 0.5) * (shakeDur / 100);
        shakeY = (Math.random() - 0.5) * (shakeDur / 100);
      } else { shakeX = 0; shakeY = 0; }

      if (flashAlpha > 0) flashAlpha -= dt * 2;

      // ── Draw ──
      ctx.save();
      ctx.translate(Math.round(shakeX), Math.round(shakeY));
      ctx.fillStyle = C.bg; ctx.fillRect(-10, -10, W + 20, H + 20);
      drawAudience(ctx);
      drawRing(ctx);
      const fighters = [player, enemy].sort((a, b) => a.y - b.y);
      for (const f of fighters) f.draw(ctx);
      drawParticles(ctx);
      drawHUD(ctx);

      // Flash overlay
      if (flashAlpha > 0) {
        ctx.fillStyle = 'rgba(255,255,255,' + flashAlpha + ')';
        ctx.fillRect(0, 0, W, H);
      }

      // Vignette
      drawVignette(ctx);

      ctx.restore();
      if (gameState === 'KO') drawKO(ctx);
    }

    // ── Party Manager ──
    const PM = {
      db: null, partyRef: null, partyId: null, isHost: false,
      playerId: 'p_' + Math.random().toString(36).substr(2, 9),
      lastGuestInput: {}, opponentConnected: false, inited: false,
      init() {
        if (typeof firebase === 'undefined' || typeof firebaseConfig === 'undefined') return;
        if (firebaseConfig.apiKey === 'YOUR_API_KEY') return;
        try { firebase.initializeApp(firebaseConfig); this.db = firebase.database(); this.inited = true; }
        catch (e) { console.error('Firebase init failed:', e); }
      },
      async createParty(pw) {
        if (!this.inited) { setStatus('FIREBASE NOT CONFIGURED'); return false; }
        if (!pw.trim()) { setStatus('ENTER A PASSWORD'); return false; }
        this.partyId = Math.random().toString(36).substr(2, 8);
        this.isHost = true;
        this.partyRef = this.db.ref('parties/' + this.partyId);
        try {
          await this.partyRef.set({ password: pw.trim().toUpperCase(), hostId: this.playerId, guestId: null, status: 'waiting', ts: firebase.database.ServerValue.TIMESTAMP });
          this.partyRef.onDisconnect().remove();
          this.partyRef.child('guestId').on('value', snap => {
            if (snap.val() && !this.opponentConnected) {
              this.opponentConnected = true;
              this.partyRef.update({ status: 'fighting' });
              startOnlineGame();
            }
          });
          this.partyRef.child('guestInput').on('value', snap => { if (snap.val()) this.lastGuestInput = snap.val(); });
          return true;
        } catch (e) { setStatus('ERROR: ' + e.message); return false; }
      },
      async joinParty(pw) {
        if (!this.inited) { setStatus('FIREBASE NOT CONFIGURED'); return false; }
        if (!pw.trim()) { setStatus('ENTER A PASSWORD'); return false; }
        try {
          const snap = await this.db.ref('parties').orderByChild('password').equalTo(pw.trim().toUpperCase()).once('value');
          const parties = snap.val();
          if (!parties) { setStatus('NO PARTY FOUND'); return false; }
          let foundId = null;
          for (const [id, p] of Object.entries(parties)) { if (p.status === 'waiting' && !p.guestId) { foundId = id; break; } }
          if (!foundId) { setStatus('PARTY IS FULL'); return false; }
          this.partyId = foundId; this.isHost = false;
          this.partyRef = this.db.ref('parties/' + foundId);
          this.opponentConnected = true;
          await this.partyRef.update({ guestId: this.playerId, status: 'fighting' });
          this.partyRef.child('guestId').onDisconnect().set(null);
          this.partyRef.child('gameState').on('value', snap => { if (snap.val()) remoteGameState = snap.val(); });
          this.partyRef.on('value', snap => { if (!snap.val()) { this.opponentConnected = false; isOnlineMode = false; gameState = 'DISCONNECTED'; document.getElementById('disconnect-msg').style.display = 'block'; } });
          startOnlineGame();
          return true;
        } catch (e) { setStatus('ERROR: ' + e.message); return false; }
      },
      sendInput(inp) { if (this.partyRef && !this.isHost) this.partyRef.child('guestInput').set(inp); },
      sendGameState(s) { if (this.partyRef && this.isHost) this.partyRef.child('gameState').set(s); },
      leave() {
        if (this.partyRef) {
          if (this.isHost) this.partyRef.remove(); else this.partyRef.update({ guestId: null, status: 'ended' });
          this.partyRef.off(); this.partyRef = null;
        }
        this.partyId = null; this.isHost = false; this.opponentConnected = false;
        this.lastGuestInput = {}; isOnlineMode = false; remoteGameState = null;
      }
    };

    function setStatus(msg) { document.getElementById('party-status').textContent = msg; }

    function startOnlineGame() {
      isOnlineMode = true; showPartyMenu = false;
      document.getElementById('party-overlay').style.display = 'none';
      resetFighters();
      player.name = 'YOU'; enemy.name = 'OPPONENT';
      roundNumber = 1; player.score = 0; enemy.score = 0;
      roundTimer = 99; roundTimerAccum = 0;
      guestActionCounts = { jab: 0, cross: 0, hook: 0, upper: 0, body: 0, jump: 0, dash: 0 };
      lastHostActionCounts = { jab: 0, cross: 0, hook: 0, upper: 0, body: 0, jump: 0, dash: 0 };
      gameState = 'FIGHTING';
    }

    function serializeGameState() {
      return {
        p1: sBoxer(player), p2: sBoxer(enemy), rn: roundNumber, rt: roundTimer,
        gs: gameState, ko: koTarget === player ? 'p1' : koTarget === enemy ? 'p2' : null,
        cc: comboCount, ct: comboTimer, la: lastAttacker === player ? 'p1' : 'p2',
        sx: shakeX, sy: shakeY, sd: shakeDur, fa: flashAlpha
      };
    }
    function sBoxer(b) {
      return {
        x: b.x | 0, y: b.y | 0, hp: Math.round(b.hp * 10) / 10, st: Math.round(b.stamina * 10) / 10,
        f: b.facing, a: b.attacking ? 1 : 0, pn: b.currentPunch ? b.currentPunch.name : 0,
        pe: Math.round(b.punchArmExt * 100) / 100, bl: b.blocking ? 1 : 0, hf: b.hitFlash > 0 ? 1 : 0,
        hs: Math.round(b.headSnapBack * 10) / 10, sn: b.stunTimer > 0 ? 1 : 0,
        bp: Math.round(b.bobPhase * 10) / 10, br: Math.round(b.breathPhase * 10) / 10,
        sp: Math.round(b.staggerPhase * 10) / 10, vy: Math.round(b.vy * 10) / 10,
        gr: b.isGrounded ? 1 : 0, kb: Math.round(b.knockbackVx * 10) / 10, sc: b.score
      };
    }
    function applyReceivedGameState(gs) {
      if (!gs || !gs.p1 || !gs.p2) return;
      // Guest is player2 (right boxer), but we display as host's perspective
      dBoxer(player, gs.p1); dBoxer(enemy, gs.p2);
      roundNumber = gs.rn; roundTimer = gs.rt;
      if (gs.gs === 'KO' && gameState !== 'KO') { gameState = 'KO'; koTarget = gs.ko === 'p1' ? player : gs.ko === 'p2' ? enemy : null; koTimer = 3; }
      else if (gs.gs === 'FIGHTING') gameState = 'FIGHTING';
      comboCount = gs.cc || 0; comboTimer = gs.ct || 0; lastAttacker = gs.la === 'p1' ? player : enemy;
      shakeX = gs.sx || 0; shakeY = gs.sy || 0; shakeDur = gs.sd || 0; flashAlpha = gs.fa || 0;
    }
    function dBoxer(b, s) {
      b.x = s.x; b.y = s.y; b.hp = s.hp; b.stamina = s.st; b.facing = s.f;
      b.attacking = !!s.a; b.currentPunch = s.pn ? PUNCHES_BY_NAME[s.pn] : null;
      b.punchArmExt = s.pe; b.blocking = !!s.bl; b.hitFlash = s.hf ? 0.1 : 0;
      b.headSnapBack = s.hs; b.stunTimer = s.sn ? 0.2 : 0;
      b.bobPhase = s.bp; b.breathPhase = s.br; b.staggerPhase = s.sp;
      b.vy = s.vy; b.isGrounded = !!s.gr; b.knockbackVx = s.kb; b.score = s.sc;
    }
    function applyGuestInput(boxer, inp) {
      if (!inp) return;
      boxer.blocking = false;
      if (inp.left) boxer.move(-1);
      if (inp.right) boxer.move(1);
      if (inp.block) {
        boxer.blocking = true;
        if (!boxer._blockStarted) { boxer.blockStartTime = performance.now(); boxer._blockStarted = true; }
      } else { boxer._blockStarted = false; }
      boxer.aimY = inp.aimY || 0;
      // Process one-shot actions via counters
      if (inp.ac) {
        if (inp.ac.jump > lastHostActionCounts.jump) boxer.jump();
        if (inp.ac.jab > lastHostActionCounts.jab) boxer.punch('jab');
        if (inp.ac.cross > lastHostActionCounts.cross) boxer.punch('cross');
        if (inp.ac.hook > lastHostActionCounts.hook) boxer.punch('hook');
        if (inp.ac.upper > lastHostActionCounts.upper) boxer.punch('uppercut');
        if (inp.ac.body > lastHostActionCounts.body) boxer.punch('bodyshot');
        if (inp.ac.dash > lastHostActionCounts.dash) boxer.punch('dashpunch');
        lastHostActionCounts = Object.assign({}, inp.ac);
      }
    }

    // ── Button Wiring ──
    document.getElementById('btn-vs-cpu').addEventListener('click', () => {
      document.getElementById('party-overlay').style.display = 'none';
      showPartyMenu = false; isOnlineMode = false;
      gameState = 'CHARSELECT';
    });

    // Character select click handling
    canvas.addEventListener('click', (e) => {
      if (gameState !== 'CHARSELECT') return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width, scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      // Check card clicks
      const cardW = 180, cardH = 280, gap = 15;
      const totalW = CHARACTERS.length * cardW + (CHARACTERS.length - 1) * gap;
      const startX = (W - totalW) / 2;
      for (let i = 0; i < CHARACTERS.length; i++) {
        const cx = startX + i * (cardW + gap), cy = 55;
        if (mx >= cx && mx <= cx + cardW && my >= cy && my <= cy + cardH) {
          selectedCharIdx = i;
        }
      }

      // Check start button click
      if (charSelectBtnRegion) {
        const b = charSelectBtnRegion;
        if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
          startGame();
        }
      }
    });

    // Hover tracking for char select
    canvas.addEventListener('mousemove', (e) => {
      if (gameState !== 'CHARSELECT') { charHoverIdx = -1; return; }
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width, scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;
      charHoverIdx = -1;
      const cardW = 180, cardH = 280, gap = 15;
      const totalW = CHARACTERS.length * cardW + (CHARACTERS.length - 1) * gap;
      const startX = (W - totalW) / 2;
      for (let i = 0; i < CHARACTERS.length; i++) {
        const cx = startX + i * (cardW + gap), cy = 55;
        if (mx >= cx && mx <= cx + cardW && my >= cy && my <= cy + cardH) {
          charHoverIdx = i;
        }
      }
    });

    // Space to start from charselect
    window.addEventListener('keydown', (e) => {
      if (gameState === 'CHARSELECT' && e.code === 'Space') {
        startGame(); e.preventDefault();
      }
    });
    document.getElementById('btn-make-party').addEventListener('click', async () => {
      const pw = document.getElementById('party-password').value;
      setStatus('');
      const ok = await PM.createParty(pw);
      if (ok) {
        document.getElementById('party-menu').style.display = 'none';
        document.getElementById('waiting-screen').style.display = 'block';
        document.getElementById('waiting-code').textContent = 'PASSWORD: ' + pw.trim().toUpperCase();
      }
    });
    document.getElementById('btn-join-party').addEventListener('click', async () => {
      const pw = document.getElementById('party-password').value;
      setStatus('');
      await PM.joinParty(pw);
    });
    document.getElementById('btn-cancel-party').addEventListener('click', () => {
      PM.leave();
      document.getElementById('waiting-screen').style.display = 'none';
      document.getElementById('party-menu').style.display = 'flex';
      showPartyMenu = true;
    });
    document.getElementById('btn-dc-ok').addEventListener('click', () => {
      document.getElementById('disconnect-msg').style.display = 'none';
      PM.leave(); showPartyMenu = false; gameState = 'TITLE';
    });
    // Prevent game keys while typing password
    document.getElementById('party-password').addEventListener('keydown', e => e.stopPropagation());
    document.getElementById('party-password').addEventListener('keyup', e => e.stopPropagation());

    // Guest key tracking for one-shot actions
    window.addEventListener('keydown', e => {
      if (!isOnlineMode || PM.isHost) return;
      const map = { KeyJ: 'jab', KeyK: 'cross', KeyL: 'hook', KeyI: 'upper', KeyU: 'body', Space: 'jump' };
      if (map[e.code]) { guestActionCounts[map[e.code]]++; }
    });

    // ── Start ──
    PM.init();
    resetFighters();
    requestAnimationFrame(gameLoop);
  </script>
</body>

</html>