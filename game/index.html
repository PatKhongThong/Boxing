<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KNOCKOUT! — Retro Boxing</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&family=Inter:wght@400;600&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box
    }

    body {
      background: #050508;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Outfit', sans-serif;
      overflow: hidden;
      cursor: crosshair;
      color: #fff;
    }

    #wrapper {
      position: relative;
    }

    canvas {
      display: block;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 0 40px rgba(255, 100, 50, .15), inset 0 0 80px rgba(0, 0, 0, .3)
    }

    #scanlines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(0deg, rgba(0, 0, 0, .08) 0px, rgba(0, 0, 0, .08) 1px, transparent 1px, transparent 3px);
      pointer-events: none;
      border: 4px solid transparent
    }

    #controls {
      color: #555;
      font-size: 7px;
      text-align: center;
      margin-top: 10px;
      line-height: 2.2
    }

    #controls span {
      color: #f85
    }

    /* Party System */
    #party-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    #party-menu {
      background: rgba(10, 5, 20, 0.94);
      border: 2px solid #f85;
      padding: 24px 32px;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      box-shadow: 0 0 40px rgba(255, 100, 50, 0.2);
    }

    #party-menu h3 {
      color: #ffdd44;
      font-family: 'Outfit', sans-serif;
      font-weight: 900;
      font-size: 16px;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #party-password {
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      padding: 12px 18px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #fff;
      text-align: center;
      outline: none;
      width: 220px;
      letter-spacing: 2px;
      text-transform: uppercase;
      transition: all 0.2s;
    }

    #party-password:focus {
      border-color: #ffdd44;
      background: rgba(255, 255, 255, 0.1);
    }

    .party-btn {
      font-family: 'Press Start 2P', monospace;
      font-size: 8px;
      padding: 10px 20px;
      border: 2px solid;
      cursor: pointer;
      transition: all 0.15s;
      letter-spacing: 1px;
      width: 220px;
    }

    #btn-vs-cpu,
    #btn-make-party,
    #btn-join-party,
    #btn-cancel-party {
      padding: 12px 24px;
      font-family: 'Outfit', sans-serif;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      width: 100%;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #btn-make-party {
      background: #4488ff;
      color: #fff;
    }

    #btn-make-party:hover {
      background: #2255bb;
    }

    #btn-join-party {
      background: #2a1a30;
      color: #44aaff;
      border-color: #44aaff;
    }

    #btn-join-party:hover {
      background: #44aaff;
      color: #000;
    }

    #btn-vs-cpu {
      background: #2a1a30;
      color: #f85;
      border-color: #f85;
    }

    #btn-vs-cpu:hover {
      background: #f85;
      color: #000;
    }

    #btn-lan-play {
      background: #1a301a;
      color: #44dd44;
      border-color: #44dd44;
    }

    #btn-lan-play:hover {
      background: #44dd44;
      color: #000;
    }

    #party-status {
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      color: #ff4444;
      min-height: 14px;
    }

    #waiting-screen {
      background: rgba(10, 5, 20, 0.95);
      border: 2px solid #f85;
      padding: 32px;
      text-align: center;
    }

    .waiting-text {
      color: #ffdd44;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .waiting-text span {
      color: #ffdd44;
      font-weight: 700;
    }

    .auth-btn {
      width: 100%;
      padding: 12px;
      border: none;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    #redeem-section {
      width: 100%;
      margin-top: 5px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #redeem-email {
      width: 100%;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #fff;
      font-family: 'Inter', sans-serif;
      font-size: 12px;
      outline: none;
      text-align: center;
    }

    #btn-redeem {
      background: #ffdd44;
      color: #000;
      font-weight: 900;
      font-size: 11px;
      border: none;
      padding: 10px;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.2s;
    }

    #btn-redeem:hover {
      background: #fff;
      box-shadow: 0 0 15px rgba(255, 221, 68, 0.4);
    }

    .waiting-code {
      color: #666;
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      margin-top: 16px;
    }

    #btn-cancel-party {
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      padding: 8px 16px;
      background: #2a1a30;
      color: #ff4444;
      border: 2px solid #ff4444;
      cursor: pointer;
      margin-top: 16px;
    }

    #btn-cancel-party:hover {
      background: #ff4444;
      color: #000;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: 0.3
      }
    }

    #disconnect-msg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 5, 20, 0.95);
      border: 2px solid #ff4444;
      padding: 24px 32px;
      text-align: center;
      z-index: 20;
      display: none;
    }

    .dc-text {
      color: #ff4444;
      font-family: 'Press Start 2P', monospace;
      font-size: 10px;
    }

    #btn-dc-ok {
      font-family: 'Press Start 2P', monospace;
      font-size: 7px;
      padding: 8px 16px;
      background: #2a1a30;
      color: #f85;
      border: 2px solid #f85;
      cursor: pointer;
      margin-top: 16px;
    }

    #btn-dc-ok:hover {
      background: #f85;
      color: #000;
    }
  </style>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
</head>

<body>
  <div>
    <div
      style="color:#777; font-size:8px; text-align:center; margin-bottom:8px; letter-spacing:1px; font-family:'Press Start 2P',monospace;">
      Made by Phat Khongthong from GIS AND I AM NOT GOING TO SING IN MATH CLASS AGAIN :)</div>
    <div id="wrapper">
      <!-- No Auth Overlay needed now! -->

      <canvas id="game" width="640" height="400"></canvas>
      <div id="scanlines"></div>
      <div id="party-overlay">
        <div id="party-menu">
          <h3>⚔ MULTIPLAYER ⚔</h3>
          <input type="text" id="party-password" placeholder="ENTER ROOM CODE" maxlength="20" autocomplete="off"
            spellcheck="false">
          <button class="party-btn" id="btn-make-party">CREATE ROOM</button>
          <button class="party-btn" id="btn-join-party">JOIN ROOM</button>
          <button class="party-btn" id="btn-vs-cpu">VS CPU</button>
          <div id="party-status"></div>

          <div id="redeem-section">
            <div style="font-size: 9px; color: #888; margin-bottom: 5px; text-transform: uppercase;">Exclusive Character
              Redeem</div>
            <input type="email" id="redeem-email" placeholder="ENTER YOUR EMAIL" autocomplete="off">
            <button id="btn-redeem">UNLOCK CONTENT</button>
          </div>
        </div>
        <div id="waiting-screen" style="display:none">
          <div class="waiting-text">WAITING FOR OPPONENT...</div>
          <div class="waiting-code" id="waiting-code"></div>
          <button id="btn-cancel-party">CANCEL</button>
        </div>
      </div>
      <div id="disconnect-msg">
        <div class="dc-text">OPPONENT LEFT</div>
        <button id="btn-dc-ok">OK</button>
      </div>
    </div>
    <div id="controls">
      <span>A/D</span> MOVE &nbsp; <span>W</span> UP &nbsp; <span>S/RMB</span> BLOCK &nbsp;
      <span>LMB</span> JAB &nbsp; <span>E</span> CROSS &nbsp;
      <span>R</span> HOOK &nbsp; <span>F</span> UPPERCUT &nbsp;
      <span>Q</span> BODY &nbsp; <span>SPACE</span> JUMP<br>
      <span>2xA/D+LMB</span> DASH PUNCH &nbsp; <span>MOUSE</span> AIM
    </div>
  </div>

  <script>
    // ============================================================
    //  KNOCKOUT! v2 — Retro 2D Boxing Game (Full Overhaul)
    // ============================================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // ── Mouse tracking ──
    let mouseX = W / 2, mouseY = H / 2;
    const canvasRect = () => canvas.getBoundingClientRect();
    canvas.addEventListener('mousemove', e => {
      const r = canvasRect();
      mouseX = (e.clientX - r.left) * (W / r.width);
      mouseY = (e.clientY - r.top) * (H / r.height);
    });

    // ── Color Palette ──
    const C = {
      bg: '#050508', ring: '#15101a', ropes: '#ff3333', ropeShadow: '#501010',
      post: '#b89850', floor: '#0d0d12', floorLine: '#1a1a25',
      p1: '#4488ff', p1dark: '#1144aa', p1skin: '#ffcc88', p1glove: '#ff2222',
      p1skinShd: '#cc9966', p1hair: '#2a1a10', p1shoe: '#1a1a2a', p1trim: '#00ccff',
      p2: '#ff4422', p2dark: '#aa1111', p2skin: '#eebb77', p2glove: '#2222ff',
      p2skinShd: '#bb8844', p2hair: '#111', p2shoe: '#221111', p2trim: '#ff8844',
      white: '#ffffff', black: '#000000',
      hpGreen: '#00ffaa', hpYellow: '#ffdd44', hpRed: '#ff4444',
      stamina: '#44aaff', gold: '#ffdd44', textShadow: 'rgba(0,0,0,0.5)',
    };

    // ── Game State ──
    let gameState = 'TITLE';
    let roundNumber = 1, roundTimer = 99, roundTimerAccum = 0;
    let koTimer = 0, koTarget = null;
    let shakeX = 0, shakeY = 0, shakeDur = 0;
    let freezeFrames = 0, particles = [], floatingTexts = [];
    let flashAlpha = 0, titleBlink = 0;
    let comboCount = 0, comboTimer = 0, lastAttacker = null;
    let slowMoTimer = 0, slowMoScale = 1;
    let ropeVibrationL = 0, ropeVibrationR = 0; // rope vibration amplitude
    let cameraFlashTimer = 0;
    let victoryTimer = 0;
    let isTestMode = false; // Training dummy mode for Chester

    // ── Input ──
    const keys = {};
    const keyDownTimes = {};
    let lastDirTap = { dir: 0, time: 0 };
    let dashPunchReady = false;
    window.addEventListener('keydown', e => {
      if (e.target.closest('input, textarea')) return;
      if (!keys[e.code]) keyDownTimes[e.code] = performance.now();
      keys[e.code] = true;
      e.preventDefault();
      // Dash punch detection: double-tap A or D
      const now = performance.now();
      if (e.code === 'KeyA' || e.code === 'KeyD') {
        const dir = e.code === 'KeyD' ? 1 : -1;
        if (dir === lastDirTap.dir && now - lastDirTap.time < 300) {
          dashPunchReady = true;
        }
        lastDirTap = { dir, time: now };
      }
    });
    window.addEventListener('keyup', e => {
      if (e.target.closest('input, textarea')) return;
      keys[e.code] = false;
    });

    // ── Mouse click (LMB = jab / dash punch, RMB = block) ──
    let mouseDown = false;
    let rmbDown = false;
    canvas.addEventListener('mousedown', e => {
      if (e.button === 0) { mouseDown = true; e.preventDefault(); }
      if (e.button === 2) { rmbDown = true; e.preventDefault(); }
    });
    canvas.addEventListener('mouseup', e => {
      if (e.button === 0) mouseDown = false;
      if (e.button === 2) rmbDown = false;
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // ── Ring ──
    const RING = { x: 60, y: 180, w: 520, h: 170 };
    const RING_CENTER_X = RING.x + RING.w / 2;

    // ── Punch Definitions ──
    const PUNCHES = {
      jab: { name: 'JAB', dmg: 5, staCost: 8, reach: 45, dur: 250, headMult: 1.3, bodyShot: false, leanX: 0, leanY: 0, armStyle: 'straight' },
      cross: { name: 'CROSS', dmg: 10, staCost: 25, reach: 55, dur: 400, headMult: 1.5, bodyShot: false, leanX: 3, leanY: 0, armStyle: 'straight' },
      hook: { name: 'HOOK', dmg: 15, staCost: 35, reach: 35, dur: 380, headMult: 1.8, bodyShot: false, leanX: 5, leanY: 0, armStyle: 'hook' },
      uppercut: { name: 'UPPERCUT', dmg: 22, staCost: 50, reach: 30, dur: 550, headMult: 2.0, bodyShot: false, leanX: 0, leanY: -3, armStyle: 'uppercut' },
      bodyshot: { name: 'BODY', dmg: 4, staCost: 10, reach: 30, dur: 250, headMult: 1.0, bodyShot: true, leanX: 4, leanY: 3, armStyle: 'straight', staDmg: 18 },
      dashpunch: { name: 'DASH', dmg: 12, staCost: 35, reach: 60, dur: 350, headMult: 1.4, bodyShot: false, leanX: 8, leanY: 0, armStyle: 'straight', dashForce: 5 },
    };
    const PUNCHES_BY_NAME = {};
    for (const [k, p] of Object.entries(PUNCHES)) PUNCHES_BY_NAME[p.name] = p;

    // ── Online Mode State ──
    let isOnlineMode = false;
    let showPartyMenu = false;
    let syncCounter = 0;
    const SYNC_RATE = 2; // Increased frequency (was 4)
    let remoteGameState = null,
      guestActionCounts = { jab: 0, cross: 0, hook: 0, upper: 0, body: 0, jump: 0, dash: 0 },
      lastHostActionCounts = { jab: 0, cross: 0, hook: 0, upper: 0, body: 0, jump: 0, dash: 0 };

    // ── Character Roster ──
    let selectedCharIdx = 0;
    let cutsceneActive = false, cutsceneTimer = 0, cutsceneBoxer = null;
    let cameraZoom = 1.0, cameraTargetX = W / 2, cameraTargetY = H / 2;
    let cameraX = W / 2, cameraY = H / 2;
    let charSelectScroll = 0;
    let charSelectTargetScroll = 0;
    let charSelectDragging = false;
    let charSelectLastDragX = 0;
    const CHARACTERS = [
      {
        name: 'FLASH',
        title: 'SPEED DEMON',
        desc: 'Lightning fast, glass cannon',
        // Stats (very different!)
        hp: 65, stamina: 130, speed: 5.5, retreatMod: 0.9, jumpForce: -10, blockDmgReduction: 0.6,
        dmgMult: 0.7, staminaRegen: 20,
        // Visual: small, lean build
        bodyScale: 0.85, headSize: 0.9, armThick: 3, legThick: 3.5,
        hairStyle: 'mohawk',
        colors: {
          main: '#22ccff', dark: '#1188aa', skin: '#ddb888', glove: '#ff2222',
          skinShd: '#bb9566', hair: '#ffdd00', shoe: '#111133', trim: '#22eeff'
        },
        // Stat display values (out of 5)
        statBars: { SPD: 5, PWR: 2, HP: 2, STA: 5, DEF: 1 }
      },
      {
        name: 'TANK',
        title: 'THE BRUISER',
        desc: 'Slow but devastating power',
        hp: 160, stamina: 70, speed: 1.8, retreatMod: 0.5, jumpForce: -6, blockDmgReduction: 0.85,
        dmgMult: 1.6, staminaRegen: 6,
        // Visual: big, wide build
        bodyScale: 1.25, headSize: 1.1, armThick: 7, legThick: 6,
        hairStyle: 'bald',
        colors: {
          main: '#ff4422', dark: '#aa2211', skin: '#c49960', glove: '#333333',
          skinShd: '#a07740', hair: '#c49960', shoe: '#441111', trim: '#ff6644'
        },
        statBars: { SPD: 1, PWR: 5, HP: 5, STA: 2, DEF: 5 }
      },
      {
        name: 'ACE',
        title: 'ALL-ROUNDER',
        desc: 'Balanced fighter, jack of all trades',
        hp: 100, stamina: 100, speed: 3, retreatMod: 0.7, jumpForce: -8, blockDmgReduction: 0.7,
        dmgMult: 1.0, staminaRegen: 12,
        // Visual: medium build
        bodyScale: 1.0, headSize: 1.0, armThick: 5, legThick: 5,
        hairStyle: 'short',
        colors: {
          main: '#4488ff', dark: '#2255bb', skin: '#ffcc88', glove: '#ff4444',
          skinShd: '#dda866', hair: '#3a2210', shoe: '#222244', trim: '#66aaff'
        },
        statBars: { SPD: 3, PWR: 3, HP: 3, STA: 3, DEF: 3 }
      },
      {
        name: 'VIPER',
        title: 'THE COUNTER-STRIKER',
        desc: 'Superior reach and elusive movement',
        hp: 90, stamina: 110, speed: 4.2, retreatMod: 0.95, jumpForce: -9.5, blockDmgReduction: 0.65,
        dmgMult: 0.9, staminaRegen: 15,
        bodyScale: 1.1, headSize: 0.95, armThick: 3.5, legThick: 4,
        hairStyle: 'short',
        colors: {
          main: '#00cc66', dark: '#006633', skin: '#8d5524', glove: '#9933ff',
          skinShd: '#663311', hair: '#1a1a1a', shoe: '#004422', trim: '#00ff88'
        },
        statBars: { SPD: 4, PWR: 3, HP: 3, STA: 4, DEF: 2 }
      },
      {
        name: 'BEAR',
        title: 'THE WALL',
        desc: 'Unshakeable defense and heavy hits',
        hp: 140, stamina: 80, speed: 2.2, retreatMod: 0.4, jumpForce: -7, blockDmgReduction: 0.9,
        dmgMult: 1.3, staminaRegen: 8,
        bodyScale: 1.15, headSize: 1.1, armThick: 6.5, legThick: 7,
        hairStyle: 'bald',
        colors: {
          main: '#664422', dark: '#442211', skin: '#eebb77', glove: '#222222',
          skinShd: '#cc9955', hair: '#664422', shoe: '#332211', trim: '#886644'
        },
        statBars: { SPD: 2, PWR: 4, HP: 4, STA: 2, DEF: 5 }
      },
      {
        name: 'STORM',
        title: 'HIGH-VOLUME BRAWLER',
        desc: 'Relentless speed and stamina',
        hp: 80, stamina: 150, speed: 4.5, retreatMod: 0.8, jumpForce: -11, blockDmgReduction: 0.55,
        dmgMult: 0.85, staminaRegen: 25,
        bodyScale: 0.95, headSize: 1.0, armThick: 4.5, legThick: 4.5,
        hairStyle: 'mohawk',
        colors: {
          main: '#ffff00', dark: '#ccaa00', skin: '#ffcc88', glove: '#0044ff',
          skinShd: '#dda866', hair: '#ffffff', shoe: '#002288', trim: '#ffff88'
        },
        statBars: { SPD: 5, PWR: 2, HP: 2, STA: 5, DEF: 2 }
      },
      {
        name: 'GHOST',
        title: 'THE INFILTRATOR',
        desc: 'Extreme speed and evasiveness',
        hp: 60, stamina: 140, speed: 5.8, retreatMod: 0.98, jumpForce: -12, blockDmgReduction: 0.5,
        dmgMult: 0.75, staminaRegen: 22,
        bodyScale: 0.8, headSize: 0.9, armThick: 2.5, legThick: 3,
        hairStyle: 'short',
        colors: {
          main: '#ffffff', dark: '#cccccc', skin: '#f0f0f0', glove: '#00ffff',
          skinShd: '#d0d0d0', hair: '#00ffff', shoe: '#003333', trim: '#00ffff'
        },
        statBars: { SPD: 5, PWR: 1, HP: 1, STA: 5, DEF: 1 }
      },
      {
        name: 'TITAN',
        title: 'THE GOLIATH',
        desc: 'Crushing power and immense reach',
        hp: 150, stamina: 85, speed: 1.5, retreatMod: 0.3, jumpForce: -5, blockDmgReduction: 0.8,
        dmgMult: 1.8, staminaRegen: 7,
        bodyScale: 1.3, headSize: 1.15, armThick: 7.5, legThick: 8,
        hairStyle: 'bald',
        colors: {
          main: '#ffcc00', dark: '#aa8800', skin: '#bb9566', glove: '#cc0000',
          skinShd: '#997544', hair: '#111', shoe: '#222', trim: '#ff0000'
        },
        statBars: { SPD: 1, PWR: 5, HP: 5, STA: 2, DEF: 4 }
      },
      {
        name: 'RONIN',
        title: 'TECHNICAL SPECIALIST',
        desc: 'Precision strikes and elite guard',
        hp: 105, stamina: 105, speed: 3.2, retreatMod: 0.85, jumpForce: -9, blockDmgReduction: 0.8,
        dmgMult: 1.1, staminaRegen: 18,
        bodyScale: 1.05, headSize: 1.0, armThick: 5, legThick: 5,
        hairStyle: 'short',
        colors: {
          main: '#1a1a4a', dark: '#0a0a2a', skin: '#f1c27d', glove: '#e0e0e0',
          skinShd: '#c19a6b', hair: '#111', shoe: '#333', trim: '#e0e0e0'
        },
        statBars: { SPD: 3, PWR: 4, HP: 3, STA: 4, DEF: 4 }
      },
      {
        name: 'BULL',
        title: 'THE AGGRESSOR',
        desc: 'Brutal close-range pressure',
        hp: 130, stamina: 90, speed: 3.8, retreatMod: 0.6, jumpForce: -7.5, blockDmgReduction: 0.7,
        dmgMult: 1.25, staminaRegen: 10,
        bodyScale: 1.1, headSize: 1.05, armThick: 7, legThick: 7,
        hairStyle: 'mohawk',
        colors: {
          main: '#ff6600', dark: '#883300', skin: '#8d5524', glove: '#333333',
          skinShd: '#663311', hair: '#ff6600', shoe: '#111', trim: '#ffcc00'
        },
        statBars: { SPD: 4, PWR: 4, HP: 4, STA: 2, DEF: 3 }
      },
      {
        name: 'CHESTER',
        title: 'THE CHICKEN',
        desc: 'Fear the feathers. Deals massive damage to unlock Cluck Fury (3x Reach/Stamina, 2x Damage).',
        hp: 200, stamina: 200, speed: 6.0, retreatMod: 1.0, jumpForce: -12, blockDmgReduction: 0.8,
        dmgMult: 1.5, staminaRegen: 30,
        bodyScale: 1.0, headSize: 1.0, armThick: 4, legThick: 4,
        hairStyle: 'chicken', // custom style
        colors: {
          main: '#ffffff', dark: '#dddddd', skin: '#ff8800', glove: '#ff2222',
          skinShd: '#cc6600', hair: '#ff2222', shoe: '#000000', trim: '#ffcc00'
        },
        statBars: { SPD: 5, PWR: 5, HP: 5, STA: 5, DEF: 5 },
        authorizedEmails: ['kasemsuwanp@gisthailand.org', 'biko@gisthailand.org', 'khongthongp@gisthailand.org']
      }
    ];

    // ── Floating damage text ──
    function spawnFloatingText(x, y, text, color) {
      floatingTexts.push({ x, y, text, color, life: 1.0, vy: -1.5 });
    }

    // ── Boxer Class ──
    class Boxer {
      constructor(x, facing, colors, name, isPlayer = false) {
        this.x = x;
        this.groundY = RING.y + RING.h - 10;
        this.y = this.groundY;
        this.facing = facing;
        this.colors = colors;
        this.name = name;
        this.isPlayer = isPlayer;

        this.hp = 100; this.maxHp = 100;
        this.stamina = 100; this.maxStamina = 100;
        this.score = 0;

        this.vx = 0; this.speed = 3; this.retreatMod = 0.7;

        // Ring depth (vertical position within ring)
        this.ringZ = 0; // 0 = bottom of ring, negative = toward top
        this.vzRing = 0; // vertical ring velocity
        this.ringZSpeed = 2.5;
        this.baseGroundY = RING.y + RING.h - 10;

        // Jump
        this.vy = 0; this.isGrounded = true;
        this.jumpForce = -8; this.gravity = 0.4;

        // Combat
        this.attacking = false; this.currentPunch = null;
        this.attackTimer = 0; this.attackCooldown = 0;
        this.hitRegistered = false;
        this.blocking = false; this.blockDmgReduction = 0.7;
        this.blockStartTime = 0; // for perfect block timing

        // Physics
        this.knockbackVx = 0;

        // Animation state
        this.bobPhase = Math.random() * Math.PI * 2;
        this.hitFlash = 0; this.punchArmExt = 0; this.bodyLean = 0;
        this.stunTimer = 0;       // stun on heavy headshot
        this.staggerPhase = 0;   // low HP stagger
        this.headSnapBack = 0;   // head snap-back on hit
        this.breathPhase = 0;    // idle breathing

        this.mouseAimAngle = 0; // angle from shoulder to mouse cursor

        // Chester Ability state
        this.abilityCharge = 0;
        this.isCluckFury = false;
        this.cluckFuryTimer = 0;
        this.barrageHits = 0; // rapid fire jabs in fury
      }

      get centerX() { return this.x; }
      get headY() { return this.y - 55 + Math.sin(this.bobPhase) * 2 + this.breathAnim; }
      get bodyY() { return this.y - 30; }
      get breathAnim() { return Math.sin(this.breathPhase) * 1.2; }
      get isStunned() { return this.stunTimer > 0; }

      update(dt) {
        this.bobPhase += dt * 4;
        this.breathPhase += dt * 2.5;

        // Stun timer
        if (this.stunTimer > 0 && !this.isCluckFury) { this.stunTimer -= dt; this.attacking = false; }
        else if (this.isCluckFury) { this.stunTimer = 0; }

        // Cluck Fury logic
        if (this.isCluckFury) {
          this.cluckFuryTimer -= dt;
          if (this.cluckFuryTimer <= 0) {
            this.isCluckFury = false;
          }
          // Buffed stamina regeneration (3.9x)
          this.stamina = Math.min(this.maxStamina, this.stamina + (this.staminaRegen || 12) * dt * 3.9);
        }

        // Stagger at low HP
        if (this.hp / this.maxHp < 0.25) {
          this.staggerPhase += dt * 6;
        } else {
          this.staggerPhase *= 0.9;
        }

        // Head snap decay
        this.headSnapBack *= 0.85;

        // Cooldowns
        if (this.attackCooldown > 0) this.attackCooldown -= dt * 1000;
        if (this.hitFlash > 0) this.hitFlash -= dt;

        // Attack timer
        if (this.attacking && !this.isStunned) {
          const punchDur = (this.barrageHits > 0) ? this.currentPunch.dur * 0.5 : this.currentPunch.dur;
          this.attackTimer -= dt * 1000;
          let progress = 1 - (this.attackTimer / punchDur);
          if (progress < 0.3) this.punchArmExt = progress / 0.3;
          else if (progress > 0.7) this.punchArmExt = (1 - progress) / 0.3;
          else this.punchArmExt = 1;
          if (this.attackTimer <= 0) {
            if (this.barrageHits > 0) {
              this.barrageHits--;
              this.attackTimer = this.currentPunch.dur * 0.5;
              this.hitRegistered = false;
              this.punchArmExt = 0;
            } else {
              this.attacking = false; this.currentPunch = null;
              this.punchArmExt = 0; this.attackCooldown = 150;
            }
          }
        }

        // Stamina regen
        if (!this.attacking && !this.blocking) {
          this.stamina = Math.min(this.maxStamina, this.stamina + (this.staminaRegen || 12) * dt);
        }

        // Jump / Gravity
        this.vy += this.gravity;
        this.y += this.vy;
        if (this.y >= this.groundY) {
          if (!this.isGrounded && Math.abs(this.vy) > 2) spawnHitParticles(this.x, this.groundY, '#aa9977', 4);
          this.y = this.groundY; this.vy = 0; this.isGrounded = true;
        } else { this.isGrounded = false; }
        if (!this.isGrounded) this.blocking = false;

        // Movement + knockback
        this.x += (this.vx + this.knockbackVx) * dt * 60;
        this.knockbackVx *= 0.88;
        if (Math.abs(this.knockbackVx) < 0.1) this.knockbackVx = 0;
        this.bodyLean += (this.vx * 0.8 - this.bodyLean) * 0.15;

        // Elastic rope bounce
        const ROPE_ZONE = 35, SPRING_K = 0.35, HARD_EDGE = 15;
        const leftEdge = RING.x + HARD_EDGE, rightEdge = RING.x + RING.w - HARD_EDGE;
        const leftPen = (RING.x + ROPE_ZONE) - this.x;
        if (leftPen > 0) {
          const force = SPRING_K * leftPen;
          this.knockbackVx += force;
          if (force > 1.5) {
            triggerShake(force * 0.5, force * 40);
            if (force > 3) { this.vy -= force * 0.3; spawnHitParticles(RING.x, this.y - 30, '#e84040', 3); ropeVibrationL = force * 2; }
          }
        }
        const rightPen = this.x - (RING.x + RING.w - ROPE_ZONE);
        if (rightPen > 0) {
          const force = SPRING_K * rightPen;
          this.knockbackVx -= force;
          if (force > 1.5) {
            triggerShake(force * 0.5, force * 40);
            if (force > 3) { this.vy -= force * 0.3; spawnHitParticles(RING.x + RING.w, this.y - 30, '#e84040', 3); ropeVibrationR = force * 2; }
          }
        }
        if (this.x < leftEdge) { this.x = leftEdge; this.knockbackVx = Math.abs(this.knockbackVx) * 0.3; }
        if (this.x > rightEdge) { this.x = rightEdge; this.knockbackVx = -Math.abs(this.knockbackVx) * 0.3; }
        this.vx = 0;

        // Ring depth movement (vertical)
        this.ringZ += this.vzRing * dt * 60;
        // Clamp within ring area (can move up to ~130px up from baseline)
        const maxUp = -(RING.h - 40);
        if (this.ringZ < maxUp) this.ringZ = maxUp;
        if (this.ringZ > 0) this.ringZ = 0;
        // Auto-drift back toward baseline when not moving
        if (this.vzRing === 0 && this.ringZ < 0) {
          this.ringZ = Math.min(0, this.ringZ + 1.5 * dt * 60);
        }
        this.groundY = this.baseGroundY + this.ringZ;
        this.vzRing = 0;
      }

      move(dir) {
        if (this.attacking || this.isStunned) return;
        let spd = this.speed;
        if ((dir > 0 && this.facing < 0) || (dir < 0 && this.facing > 0)) spd *= this.retreatMod;
        this.vx = dir * spd;
      }

      jump() {
        if (!this.isGrounded || this.attacking || this.isStunned) return;
        this.vy = this.jumpForce; this.isGrounded = false;
      }

      moveZ(dir) {
        if (this.attacking || this.isStunned) return;
        this.vzRing = dir * this.ringZSpeed;
      }

      punch(type) {
        if (this.attacking || this.attackCooldown > 0 || this.blocking || !this.isGrounded || this.isStunned) return;
        const p = PUNCHES[type];
        if (!p || this.stamina < p.staCost) return;
        this.stamina -= p.staCost;
        this.attacking = true; this.currentPunch = p;
        this.attackTimer = p.dur; this.hitRegistered = false;

        // Mutated Jab Barrage
        if (type === 'jab' && this.isCluckFury && this.name === 'CHESTER') {
          this.barrageHits = 9; // 10 hits total
        } else {
          this.barrageHits = 0;
        }

        // Dash punch forward burst
        if (p.dashForce) this.knockbackVx += this.facing * p.dashForce;
      }

      getHitbox() {
        if (!this.attacking || !this.currentPunch || this.hitRegistered) return null;
        const ext = this.punchArmExt;
        if (ext < 0.7) return null;
        const p = this.currentPunch;
        const reachBoost = this.isCluckFury ? 3.0 : 1.0;
        const hx = this.x + this.facing * (15 + p.reach * ext * reachBoost);
        // Mouse aim shifts hitbox Y for player
        let hy = this.headY - 5 + (this.isPlayer ? this.aimY * 15 : 0);
        if (p.bodyShot) hy = this.bodyY - 5;
        return { x: hx - 12 * reachBoost, y: hy, w: 24 * reachBoost, h: p.bodyShot ? 20 : 30 };
      }

      getHurtbox() {
        return { x: this.x - 14, y: this.headY - 10, w: 28, h: 65 };
      }

      takeDamage(dmg, attackerX, punch, isHead) {
        let finalDmg = dmg;
        // Perfect block: if block started < 150ms ago, extra reduction
        let perfectBlock = false;
        if (this.blocking) {
          const blockDur = performance.now() - this.blockStartTime;
          if (blockDur < 150) {
            finalDmg *= 0.1; // 90% reduction on perfect block
            perfectBlock = true;
            spawnFloatingText(this.x, this.headY - 20, 'PERFECT!', '#44ffff');
          } else {
            finalDmg *= (1 - this.blockDmgReduction);
          }
          this.stamina -= (perfectBlock ? dmg * 0.1 : dmg * 0.3);
        }

        // Body shot: extra stamina damage
        if (punch && punch.bodyShot) {
          this.stamina -= (punch.staDmg || 15);
          if (this.stamina < 0) this.stamina = 0;
        }

        // 3.9x Defense buff during Cluck Fury
        if (this.isCluckFury) finalDmg /= 3.9;

        this.hp -= finalDmg;
        this.hitFlash = 0.15;

        // Head snap-back on heavy hit
        if (isHead && finalDmg > 8) {
          this.headSnapBack = Math.min(8, finalDmg * 0.4) * (attackerX < this.x ? 1 : -1);
        }

        // Stun on strong headshot
        if (isHead && finalDmg > 18 && !this.blocking) {
          this.stunTimer = 0.4 + finalDmg * 0.01;
          spawnFloatingText(this.x, this.headY - 30, 'STUN!', '#ffff44');
        }

        // Knockback + uppercut vertical launch
        const dir = attackerX < this.x ? 1 : -1;
        this.knockbackVx += dir * (finalDmg * 0.25);
        if (punch && punch.name === 'UPPERCUT' && finalDmg > 10) {
          this.vy -= Math.min(4, finalDmg * 0.12);
        }

        // Floating damage number
        if (finalDmg > 0.5) {
          const col = isHead ? '#ffff44' : (punch && punch.bodyShot ? '#44aaff' : '#ff8844');
          spawnFloatingText(this.x + (Math.random() - 0.5) * 20, this.headY - 15, Math.round(finalDmg).toString(), col);
        }

        // Stun on strong headshot
        if (isHead && finalDmg > 18 && !this.blocking) {
          this.stunTimer = 0.4 + finalDmg * 0.01;
          spawnFloatingText(this.x, this.headY - 30, 'STUN!', '#ffff44');
        }
      }

      draw(ctx) {
        const bob = Math.sin(this.bobPhase) * 2 + this.breathAnim;
        const stagger = Math.sin(this.staggerPhase) * (this.hp / this.maxHp < 0.25 ? 2 : 0);
        const lean = this.bodyLean + stagger;
        const f = this.facing;
        const flash = this.hitFlash > 0;
        const punchLean = this.currentPunch ? this.currentPunch.leanX * this.punchArmExt * f : 0;
        const punchLeanY = this.currentPunch ? this.currentPunch.leanY * this.punchArmExt : 0;
        const lx = lean + punchLean; // combined lean X
        const ly = punchLeanY;       // combined lean Y

        // Aura for Cluck Fury
        if (this.isCluckFury) {
          ctx.save();
          ctx.globalAlpha = 0.4 + Math.sin(Date.now() * 0.01) * 0.2;
          ctx.shadowBlur = 25; ctx.shadowColor = '#ff0000';
          ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 15;
          ctx.beginPath();
          ctx.ellipse(lx, -30 + bob + ly, 20, 40, 0, 0, Math.PI * 2);
          ctx.stroke();
          // Inner glow layer
          ctx.globalAlpha = 0.2 + Math.sin(Date.now() * 0.015) * 0.15;
          ctx.shadowBlur = 40; ctx.shadowColor = '#ff2200';
          ctx.strokeStyle = '#ff4400'; ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.ellipse(lx, -30 + bob + ly, 25, 45, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        const isMutated = this.isCluckFury && this.name === 'CHESTER';
        const sk = flash ? '#fff' : (isMutated ? '#1a1a1a' : this.colors.skin);
        const skShd = flash ? '#ddd' : (isMutated ? '#0d0d0d' : (this.colors.skinShd || this.colors.skin));
        const mainC = flash ? '#fff' : (isMutated ? '#330000' : this.colors.main);
        const darkC = flash ? '#ddd' : (isMutated ? '#1a0000' : this.colors.dark);
        const gc = flash ? '#fff' : (isMutated ? '#ff0000' : this.colors.glove);
        const hairC = flash ? '#eee' : (isMutated ? '#ff0000' : (this.colors.hair || this.colors.dark));
        const shoeC = flash ? '#fff' : (isMutated ? '#1a0000' : (this.colors.shoe || '#222'));
        const trimC = flash ? '#fff' : (isMutated ? '#ff0000' : (this.colors.trim || this.colors.main));
        const now = performance.now();

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';

        const s = this.bodyScale || 1.0;

        // ── Ground Shadow (Soft Gradient) ──
        const jumpH = this.groundY - this.y;
        const ss = Math.max(0.2, 1 - jumpH / 100);
        const shadowGrd = ctx.createRadialGradient(0, this.groundY - this.y + 2, 0, 0, this.groundY - this.y + 2, 25 * ss * s);
        shadowGrd.addColorStop(0, `rgba(0,0,0,${0.4 * ss})`);
        shadowGrd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = shadowGrd;
        ctx.beginPath();
        ctx.ellipse(0, this.groundY - this.y + 2, 25 * ss * s, 8 * ss * s, 0, 0, Math.PI * 2);
        ctx.fill();

        // ── Helper: draw high-fidelity limb ──
        const drawLimb = (sx, sy, ex, ey, thick, color, muscleLvl = 1) => {
          const midX = (sx + ex) * 0.5 + (ey - sy) * 0.15 * f;
          const midY = (sy + ey) * 0.5 + (sx - ex) * 0.05;

          // Outer Stroke / Skin
          ctx.strokeStyle = color; ctx.lineWidth = thick;
          ctx.beginPath(); ctx.moveTo(sx, sy); ctx.quadraticCurveTo(midX, midY, ex, ey); ctx.stroke();

          if (!flash) {
            // Muscle Highlighting
            ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = thick * 0.3;
            ctx.beginPath(); ctx.moveTo(sx + f * 1, sy); ctx.quadraticCurveTo(midX + f * 1, midY, ex + f * 1, ey); ctx.stroke();
            // Muscle Shadows
            ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = thick * 0.4;
            ctx.beginPath(); ctx.moveTo(sx - f * 2, sy + 1); ctx.quadraticCurveTo(midX - f * 2, midY + 1, ex - f * 2, ey + 1); ctx.stroke();
          }
        };

        const hipY = -15 * s + bob + ly;
        const legThick = this.legThick * s;

        // ── Back Leg ──
        const blHipX = -f * 6 * s + lx, blFootX = -f * 14 * s;
        drawLimb(blHipX, hipY, blFootX, -1, legThick, skShd);
        // Boot (Back)
        ctx.fillStyle = shoeC;
        ctx.beginPath(); ctx.roundRect(blFootX - 6 * s, -4 * s, 12 * s, 6 * s, 3 * s); ctx.fill();

        // ── Front Leg ──
        const flHipX = f * 6 * s + lx, flFootX = f * 14 * s;
        drawLimb(flHipX, hipY, flFootX, -1, legThick + 1, sk);
        // Boot (Front)
        ctx.fillStyle = shoeC;
        ctx.beginPath(); ctx.roundRect(flFootX - 7 * s, -5 * s, 14 * s, 7 * s, 4 * s); ctx.fill();
        // Boot detail (sole + laces)
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(flFootX - 7 * s, -1 * s, 14 * s, 2 * s);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1;
        for (let li = 0; li < 3; li++) { ctx.beginPath(); ctx.moveTo(flFootX - 3 * s, -4 * s + li * 2 * s); ctx.lineTo(flFootX + 3 * s, -4 * s + li * 2 * s); ctx.stroke(); }

        // ── Shorts ──
        const sw = 13 * s, sh = 16 * s;
        ctx.fillStyle = mainC;
        ctx.beginPath();
        ctx.roundRect(-sw + lx, -sh - 5 * s + bob + ly, sw * 2, sh, [2 * s, 2 * s, 6 * s, 6 * s]);
        ctx.fill();
        // Waistband
        const grdW = ctx.createLinearGradient(0, -sh - 5 * s + bob + ly, 0, -sh - 1 * s + bob + ly);
        grdW.addColorStop(0, darkC); grdW.addColorStop(1, mainC);
        ctx.fillStyle = grdW;
        ctx.beginPath(); ctx.roundRect(-sw + lx, -sh - 5 * s + bob + ly, sw * 2, 5 * s, 2 * s); ctx.fill();
        // Trim
        ctx.strokeStyle = trimC; ctx.lineWidth = 2 * s;
        ctx.beginPath(); ctx.moveTo(-sw + lx, -5 * s + bob + ly); ctx.lineTo(sw + lx, -5 * s + bob + ly); ctx.stroke();

        // ── Torso (Anatomical path) ──
        const tw = 14 * s, th = 24 * s;
        const tx = lx, ty = -sh - 5 * s + bob + ly;

        // Torso Base Gradient
        const bodyGrd = ctx.createRadialGradient(tx + f * 5 * s, ty - th * 0.7, 5 * s, tx, ty - th * 0.5, th);
        bodyGrd.addColorStop(0, sk); bodyGrd.addColorStop(1, skShd);
        ctx.fillStyle = bodyGrd;

        ctx.beginPath();
        ctx.moveTo(tx - sw + 2 * s, ty); // waist left
        ctx.bezierCurveTo(tx - tw - 2 * s, ty - 8 * s, tx - tw - 4 * s, ty - th + 5 * s, tx - tw, ty - th); // side left
        ctx.lineTo(tx + tw, ty - th); // shoulder line
        ctx.bezierCurveTo(tx + tw + 4 * s, ty - th + 5 * s, tx + tw + 2 * s, ty - 8 * s, tx + sw - 2 * s, ty); // side right
        ctx.closePath(); ctx.fill();

        if (!flash) {
          // Muscle Definition Lines
          ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1 * s;
          // Center line
          ctx.beginPath(); ctx.moveTo(tx, ty - th + 4 * s); ctx.lineTo(tx, ty - 4 * s); ctx.stroke();
          // Pecs
          ctx.beginPath(); ctx.arc(tx - 6 * s, ty - th + 8 * s, 6 * s, 0, Math.PI * 0.8); ctx.stroke();
          ctx.beginPath(); ctx.arc(tx + 6 * s, ty - th + 8 * s, 6 * s, Math.PI * 0.2, Math.PI); ctx.stroke();
          // Abs
          for (let i = 0; i < 3; i++) {
            ctx.beginPath(); ctx.moveTo(tx - 4 * s, ty - 6 * s - i * 5 * s); ctx.lineTo(tx + 4 * s, ty - 6 * s - i * 5 * s); ctx.stroke();
          }
          // Rim Light
          ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 1.5 * s;
          ctx.beginPath(); ctx.moveTo(tx + tw - 1 * s, ty - th + 2 * s); ctx.lineTo(tx + sw - 3 * s, ty - 2 * s); ctx.stroke();
        }

        // ── Arms ──
        const ARM_T = this.armThick * s;
        const sY = ty - th + 3 * s;
        const sLX = tx - tw, sRX = tx + tw;

        const drawHighFidArm = (sx, sy, ex, ey, thick, isBack) => {
          const elbX = (sx + ex) * 0.5 + (ey - sy) * 0.25 * f;
          const elbY = (sy + ey) * 0.5 + Math.abs(ex - sx) * 0.2;

          // Arm Path
          ctx.strokeStyle = isBack ? skShd : sk; ctx.lineWidth = thick;
          ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(elbX, elbY); ctx.lineTo(ex, ey); ctx.stroke();

          // Bicep bulge
          ctx.fillStyle = isBack ? skShd : sk;
          ctx.beginPath(); ctx.arc((sx + elbX) * 0.5, (sy + elbY) * 0.5 - 1, thick * 0.6, 0, Math.PI * 2); ctx.fill();

          // Glove (Premium)
          const gloveR = 10 * s;
          const gloveGrd = ctx.createRadialGradient(ex - f * 3 * s, ey - 3 * s, 0, ex, ey, gloveR);
          gloveGrd.addColorStop(0, gc); gloveGrd.addColorStop(0.8, gc); gloveGrd.addColorStop(1, 'rgba(0,0,0,0.3)');
          ctx.fillStyle = gloveGrd;
          ctx.beginPath(); ctx.arc(ex, ey, gloveR, 0, Math.PI * 2); ctx.fill();
          // Thumb nub
          ctx.beginPath(); ctx.arc(ex + (isBack ? -f : f) * 6 * s, ey + 4 * s, 4 * s, 0, Math.PI * 2); ctx.fill();
          // Gloss
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath(); ctx.ellipse(ex - f * 4 * s, ey - 4 * s, 4 * s, 2 * s, Math.PI * 0.25, 0, Math.PI * 2); ctx.fill();
        };

        const drawWingArm = (sx, sy, ex, ey, thick, isBack) => {
          // Chicken wings instead of arms
          ctx.strokeStyle = isBack ? skShd : sk; ctx.lineWidth = thick;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          const cpX = (sx + ex) * 0.5 - f * 20 * s;
          ctx.quadraticCurveTo(cpX, (sy + ey) * 0.5, ex, ey);
          ctx.stroke();

          // Feather details
          ctx.fillStyle = isBack ? skShd : sk;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.ellipse(ex - f * (i * 4 * s), ey, 8 * s, 4 * s, Math.PI * 0.5 - f * 0.5, 0, Math.PI * 2);
            ctx.fill();
          }
        };

        const isIdle = this.isPlayer && !this.attacking && !this.blocking && !this.isStunned;
        const armDrawer = this.name === 'CHESTER' ? drawWingArm : drawHighFidArm;
        if (isIdle) {
          const angle = this.mouseAimAngle;
          const aL = 35 * s;
          const ax = Math.cos(angle) * aL, ay = Math.sin(angle) * aL;
          armDrawer(sLX, sY, sLX + ax * 0.9, sY + ay * 0.9, ARM_T - 0.5, true);
          armDrawer(sRX, sY, sRX + ax, sY + ay, ARM_T, false);
        } else {
          // Back Arm
          const beX = tx - f * 18 * s, beY = ty - th + 10 * s + (this.blocking ? -12 * s : 0);
          armDrawer(sLX, sY, beX, beY, ARM_T - 0.5, true);
          // Front Arm
          let feX = tx + f * 18 * s, feY = ty - th + 12 * s;
          if (this.attacking && this.currentPunch) {
            const p = this.currentPunch;
            const ext = this.punchArmExt;
            feX = tx + f * (18 * s + p.reach * ext);
            feY = ty - th + 12 * s + p.leanY * 5 * s - (p.armStyle === 'uppercut' ? ext * 20 * s : 0);
          }
          if (this.blocking) { feX = tx + f * 10 * s; feY = ty - th - 5 * s; }
          if (this.isStunned) { feX += Math.sin(now * 0.02) * 6; feY += Math.cos(now * 0.015) * 4; }
          armDrawer(sRX, sY, feX, feY, ARM_T, false);
        }

        // ── Head (Detailed) ──
        const hRad = 10 * this.headSize * s;
        const hX = lx + this.headSnapBack * s;
        const hY = ty - th - hRad - 2 * s;

        // Neck
        ctx.strokeStyle = sk; ctx.lineWidth = 6 * s;
        ctx.beginPath(); ctx.moveTo(lx, ty - th + 2 * s); ctx.lineTo(hX, hY + 5 * s); ctx.stroke();

        // Head Gradient
        const headGrd = ctx.createRadialGradient(hX + f * 4 * s, hY - 4 * s, 0, hX, hY, hRad);
        headGrd.addColorStop(0, sk); headGrd.addColorStop(1, skShd);
        ctx.fillStyle = headGrd;
        ctx.beginPath(); ctx.ellipse(hX, hY, hRad, hRad * 1.1, 0, 0, Math.PI * 2); ctx.fill();

        if (!flash) {
          // Hair
          ctx.fillStyle = hairC;
          if (this.hairStyle === 'mohawk') {
            for (let i = -4; i <= 4; i++) {
              ctx.beginPath(); ctx.moveTo(hX + i * 2 * s, hY - hRad + 2 * s);
              ctx.lineTo(hX + i * 1.5 * s, hY - hRad - 8 * s);
              ctx.lineTo(hX + i * 2 * s + 2 * s, hY - hRad + 2 * s); ctx.fill();
            }
          } else if (this.hairStyle === 'short') {
            ctx.beginPath(); ctx.arc(hX, hY - 2 * s, hRad + 1, Math.PI, 0); ctx.fill();
          } else if (this.hairStyle === 'bald') {
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.beginPath(); ctx.arc(hX - 3 * s, hY - 5 * s, 4 * s, 0, Math.PI * 2); ctx.fill();
          } else if (this.hairStyle === 'chicken') {
            // Red Comb
            ctx.fillStyle = '#ff2222';
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.arc(hX - 4 * s + i * 5 * s, hY - hRad - 2 * s, 4 * s, 0, Math.PI * 2);
              ctx.fill();
            }
            // Beak (Orange)
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(hX + f * hRad, hY);
            ctx.lineTo(hX + f * (hRad + 12 * s), hY + 4 * s);
            ctx.lineTo(hX + f * hRad, hY + 8 * s);
            ctx.closePath();
            ctx.fill();
            // Beak bottom
            ctx.fillStyle = '#ccaa00';
            ctx.beginPath();
            ctx.moveTo(hX + f * hRad, hY + 4 * s);
            ctx.lineTo(hX + f * (hRad + 8 * s), hY + 8 * s);
            ctx.lineTo(hX + f * hRad, hY + 10 * s);
            ctx.closePath();
            ctx.fill();
          }

          // Eyes
          ctx.fillStyle = '#fff';
          const eyeOff = f * 5 * s;
          if (this.isStunned) {
            ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(hX + eyeOff - 3, hY - 2 - 3); ctx.lineTo(hX + eyeOff + 3, hY - 2 + 3); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(hX + eyeOff + 3, hY - 2 - 3); ctx.lineTo(hX + eyeOff - 3, hY - 2 + 3); ctx.stroke();
          } else {
            ctx.beginPath(); ctx.ellipse(hX + eyeOff, hY - 1 * s, 3 * s, 2.5 * s, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(hX + eyeOff + f * 1 * s, hY - 0.5 * s, 1.2 * s, 0, Math.PI * 2); ctx.fill();
          }

          // Nose & Mouth
          ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.moveTo(hX + f * 7 * s, hY - 1 * s); ctx.lineTo(hX + f * 9 * s, hY + 1 * s); ctx.lineTo(hX + f * 7 * s, hY + 2 * s); ctx.stroke();

          ctx.beginPath();
          if (this.hp / this.maxHp < 0.3) ctx.arc(hX + f * 4 * s, hY + 6 * s, 3 * s, 0.3, Math.PI - 0.3);
          else { ctx.moveTo(hX + f * 3 * s, hY + 5 * s); ctx.lineTo(hX + f * 7 * s, hY + 4 * s); }
          ctx.stroke();
        }

        // ── Sweat drops when stamina low ──
        if (!flash && this.stamina / this.maxStamina < 0.35) {
          ctx.fillStyle = '#88ccff'; ctx.globalAlpha = 0.6;
          const swPhase = now * 0.003 + this.bobPhase;
          for (let si = 0; si < 2; si++) {
            const sdx = Math.sin(swPhase + si * 3) * 8 * s;
            const sdy = (now * 0.04 + si * 20) % 30 - 15;
            ctx.beginPath(); ctx.arc(hX + sdx, hY - 5 * s + sdy, 1.2 * s, 0, Math.PI * 2); ctx.fill();
          }
          ctx.globalAlpha = 1;
        }

        ctx.restore();
      }
    }

    // ── Fighters ──
    let player, enemy;
    function resetFighters() {
      const ch = CHARACTERS[selectedCharIdx];
      player = new Boxer(RING.x + 120, 1, {
        main: ch.colors.main, dark: ch.colors.dark, skin: ch.colors.skin, glove: ch.colors.glove,
        skinShd: ch.colors.skinShd, hair: ch.colors.hair, shoe: ch.colors.shoe, trim: ch.colors.trim
      }, ch.name, true);
      // Apply character stats to player
      player.hp = ch.hp; player.maxHp = ch.hp;
      player.stamina = ch.stamina; player.maxStamina = ch.stamina;
      player.speed = ch.speed; player.retreatMod = ch.retreatMod;
      player.jumpForce = ch.jumpForce; player.blockDmgReduction = ch.blockDmgReduction;
      player.dmgMult = ch.dmgMult; player.staminaRegen = ch.staminaRegen;
      player.bodyScale = ch.bodyScale; player.headSize = ch.headSize;
      player.armThick = ch.armThick; player.legThick = ch.legThick;
      player.hairStyle = ch.hairStyle;

      // CPU always picks a random different character
      let cpuIdx = Math.floor(Math.random() * CHARACTERS.length);
      while (cpuIdx === selectedCharIdx && CHARACTERS.length > 1) cpuIdx = Math.floor(Math.random() * CHARACTERS.length);
      const cpuCh = isOnlineMode ? CHARACTERS[PM.enemyCharIdx] : CHARACTERS[cpuIdx];
      enemy = new Boxer(RING.x + RING.w - 120, -1, {
        main: cpuCh.colors.main, dark: cpuCh.colors.dark, skin: cpuCh.colors.skin, glove: cpuCh.colors.glove,
        skinShd: cpuCh.colors.skinShd, hair: cpuCh.colors.hair, shoe: cpuCh.colors.shoe, trim: cpuCh.colors.trim
      }, isOnlineMode ? 'OPPONENT' : cpuCh.name, false);
      enemy.hp = cpuCh.hp; enemy.maxHp = cpuCh.hp;
      enemy.stamina = cpuCh.stamina; enemy.maxStamina = cpuCh.stamina;
      enemy.speed = cpuCh.speed; enemy.retreatMod = cpuCh.retreatMod;
      enemy.jumpForce = cpuCh.jumpForce; enemy.blockDmgReduction = cpuCh.blockDmgReduction;
      enemy.dmgMult = cpuCh.dmgMult; enemy.staminaRegen = cpuCh.staminaRegen;
      enemy.bodyScale = cpuCh.bodyScale; enemy.headSize = cpuCh.headSize;
      enemy.armThick = cpuCh.armThick; enemy.legThick = cpuCh.legThick;
      enemy.hairStyle = cpuCh.hairStyle;
    }
    function resetRound() {
      resetFighters();
      roundTimer = 99; roundTimerAccum = 0;
      particles = []; floatingTexts = [];
      flashAlpha = 0; freezeFrames = 0; shakeDur = 0;
      comboCount = 0; comboTimer = 0;
      slowMoTimer = 0; slowMoScale = 1;
      ropeVibrationL = 0; ropeVibrationR = 0;
      victoryTimer = 0;
      gameState = 'FIGHTING';
    }
    function startGame() {
      isTestMode = false;
      roundNumber = 1;
      if (player) player.score = 0;
      if (enemy) enemy.score = 0;
      if (isOnlineMode) {
        let guestActionCounts = { jab: 0, cross: 0, hook: 0, upper: 0, body: 0, jump: 0, dash: 0 };
        let lastHostActionCounts = { jab: 0, cross: 0, hook: 0, upper: 0, body: 0, jump: 0, dash: 0 };
        remoteGameState = null;
      }
      resetRound();
    }

    function startTestMode() {
      isTestMode = true; isOnlineMode = false;
      roundNumber = 1;
      // Create player as Chester
      resetFighters();
      // Override enemy as a training dummy
      enemy.name = 'DUMMY';
      enemy.hp = 99999; enemy.maxHp = 99999;
      enemy.speed = 0; enemy.dmgMult = 0;
      enemy.staminaRegen = 0;
      enemy.colors = { main: '#555', dark: '#333', skin: '#888', glove: '#666', skinShd: '#666', hair: '#444', shoe: '#333', trim: '#555' };
      roundTimer = 999; roundTimerAccum = 0;
      particles = []; floatingTexts = [];
      flashAlpha = 0; freezeFrames = 0; shakeDur = 0;
      comboCount = 0; comboTimer = 0;
      slowMoTimer = 0; slowMoScale = 1;
      ropeVibrationL = 0; ropeVibrationR = 0;
      victoryTimer = 0;
      gameState = 'FIGHTING';
    }

    // ── Smart AI Controller ──
    const AI = {
      state: 'IDLE', lastDecision: 0, comboStep: 0, comboSeq: null,
      feinting: false, feintTimer: 0,

      getReactionDelay() { return Math.max(200, 700 - roundNumber * 50) + Math.random() * 200; },
      getAggression() { return Math.min(0.95, 0.3 + roundNumber * 0.08); },

      update(dt, cpu, target) {
        const now = performance.now();
        const dist = Math.abs(cpu.x - target.x);
        const tHpPct = target.hp / target.maxHp;
        const cHpPct = cpu.hp / cpu.maxHp;
        const cStaPct = cpu.stamina / cpu.maxStamina;
        const tStaPct = target.stamina / target.maxStamina;
        const aggression = this.getAggression();

        // Feint timer
        if (this.feinting) { this.feintTimer -= dt * 1000; if (this.feintTimer <= 0) this.feinting = false; }

        if (now - this.lastDecision > this.getReactionDelay()) {
          this.lastDecision = now;

          // Counterattack: if target just whiffed (attacking but no hit registered and timer almost done)
          if (target.attacking && !target.hitRegistered && target.attackTimer < 100 && dist < 80) {
            this.state = 'COUNTER';
          } else if (cpu.stamina < 20) {
            this.state = 'RETREAT';
          } else if (dist > 180) {
            this.state = 'CHASE';
          } else if (dist < 40) {
            this.state = Math.random() < 0.4 ? 'RETREAT' : 'PRESSURE';
          } else if (dist <= 100 && cStaPct > 0.3) {
            this.state = Math.random() < aggression ? 'ATTACK' : 'IDLE';
          } else {
            this.state = 'IDLE';
          }
        }

        const dir = target.x > cpu.x ? 1 : -1;
        cpu.blocking = false;

        // AI Z-tracking: wobbly, delayed tracking of player's ring depth
        const wobble = Math.sin(now * 0.002 + cpu.x * 0.1) * 20;
        const zDiff = (target.groundY + wobble) - cpu.groundY;
        if (Math.abs(zDiff) > 30 && Math.random() < 0.6) {
          cpu.moveZ(zDiff < 0 ? -1 : 1);
        } else if (Math.random() < 0.02) {
          // Occasional random wander up/down
          cpu.moveZ(Math.random() < 0.5 ? -1 : 1);
        }

        switch (this.state) {
          case 'CHASE': cpu.move(dir); break;
          case 'RETREAT':
            cpu.move(-dir);
            cpu.blocking = Math.random() < 0.6;
            break;
          case 'COUNTER':
            cpu.move(dir * 0.5);
            if (!cpu.attacking && Math.random() < 0.25) {
              const r = Math.random();
              if (r < 0.3) cpu.punch('hook');
              else if (r < 0.6) cpu.punch('cross');
              else cpu.punch('uppercut');
            }
            break;
          case 'PRESSURE':
            cpu.move(dir * 0.3);
            if (!cpu.attacking && Math.random() < 0.12) {
              // Target head when low HP
              if (tHpPct < 0.3 && Math.random() < 0.6) {
                cpu.punch(Math.random() < 0.5 ? 'hook' : 'uppercut');
              }
              // Body shot when target low stamina
              else if (tStaPct < 0.4 && Math.random() < 0.5) {
                cpu.punch('bodyshot');
              } else {
                cpu.punch('jab');
              }
            }
            break;
          case 'ATTACK':
            if (dist > 70) cpu.move(dir * 0.5);
            if (!cpu.attacking) {
              // Attempt combos at higher rounds
              if (this.comboSeq && this.comboStep < this.comboSeq.length) {
                if (Math.random() < 0.15) {
                  cpu.punch(this.comboSeq[this.comboStep]);
                  this.comboStep++;
                }
              } else if (Math.random() < 0.08 + roundNumber * 0.01) {
                // Start a combo or single punch
                const r = Math.random();
                if (r < 0.15 && roundNumber >= 2) {
                  this.comboSeq = ['jab', 'cross', 'hook'];
                  this.comboStep = 0;
                  cpu.punch('jab');
                  this.comboStep = 1;
                } else if (r < 0.35) cpu.punch('jab');
                else if (r < 0.55) cpu.punch('cross');
                else if (r < 0.7) cpu.punch('hook');
                else if (r < 0.82) cpu.punch('uppercut');
                else if (r < 0.9) cpu.punch('bodyshot');
                else {
                  // Feint: fake start without actual punch
                  this.feinting = true;
                  this.feintTimer = 200;
                }
              }
              // Occasional jump attack
              if (Math.random() < 0.003) cpu.jump();
            }
            break;
          case 'IDLE':
            if (Math.random() < 0.03) cpu.move(dir * 0.3);
            cpu.blocking = Math.random() < 0.15 + roundNumber * 0.03;
            if (Math.random() < 0.004) cpu.jump();
            break;
        }
      }
    };

    // ── Particles ──
    function spawnHitParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y, vx: (Math.random() - 0.5) * 6, vy: -Math.random() * 4 - 1,
          life: 0.3 + Math.random() * 0.3, color, size: 2 + Math.random() * 3
        });
      }
    }
    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 6 * dt; p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i]; t.y += t.vy; t.life -= dt;
        if (t.life <= 0) floatingTexts.splice(i, 1);
      }
    }
    function drawParticles(ctx) {
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, p.life * 3);
        ctx.fillStyle = p.color;
        ctx.fillRect(Math.round(p.x), Math.round(p.y), Math.round(p.size), Math.round(p.size));
      }
      ctx.globalAlpha = 1;
      // Floating text
      ctx.font = '6px "Press Start 2P"'; ctx.textAlign = 'center';
      for (const t of floatingTexts) {
        ctx.globalAlpha = Math.max(0, t.life);
        ctx.fillStyle = '#000'; ctx.fillText(t.text, t.x + 1, t.y + 1);
        ctx.fillStyle = t.color; ctx.fillText(t.text, t.x, t.y);
      }
      ctx.globalAlpha = 1;
    }

    // ── Hit Detection ──
    function checkHits() { doHitCheck(player, enemy); doHitCheck(enemy, player); }
    function doHitCheck(attacker, victim) {
      // Z-distance check: fighters must be at similar ring depth to connect
      const zDist = Math.abs(attacker.groundY - victim.groundY);
      if (zDist > 25) return; // too far apart vertically in ring
      const hb = attacker.getHitbox();
      if (!hb) return;
      const hr = victim.getHurtbox();
      if (hb.x < hr.x + hr.w && hb.x + hb.w > hr.x && hb.y < hr.y + hr.h && hb.y + hb.h > hr.y) {
        attacker.hitRegistered = true;
        const hitY = hb.y + hb.h / 2;
        const headZone = victim.headY + 5;
        let dmg = attacker.currentPunch.dmg * (attacker.dmgMult || 1);
        if (attacker.isCluckFury) dmg *= 5.0; // 5x Damage buff during Cluck Fury

        // Barrage override: each hit deals 1/10 of victim's remaining HP (always lethal after 10 hits)
        if (attacker.barrageHits > 0 || (attacker.isCluckFury && attacker.currentPunch.name === 'JAB')) {
          dmg = victim.hp / 10;
          // Freeze victim during barrage
          victim.stunTimer = Math.max(victim.stunTimer, 0.3);
          victim.knockbackVx = 0;
        }

        let isHead = hitY < headZone && !attacker.currentPunch.bodyShot;
        if (isHead && !(attacker.barrageHits > 0)) dmg *= attacker.currentPunch.headMult;

        victim.takeDamage(dmg, attacker.x, attacker.currentPunch, isHead);

        // Ability charging (offensive)
        if (attacker.name === 'CHESTER' && !attacker.isCluckFury) {
          attacker.abilityCharge = Math.min(100, attacker.abilityCharge + dmg * 3.5);
        }


        // Crowd reacts to hits
        boostCrowdExcitement(dmg * 0.008 + (isHead ? 0.05 : 0));

        // Combo counter
        if (attacker === lastAttacker && comboTimer > 0) {
          comboCount++;
        } else { comboCount = 1; }
        lastAttacker = attacker; comboTimer = 1.5;
        // Crowd goes wild for combos
        if (comboCount >= 3) boostCrowdExcitement(0.15);
        if (comboCount >= 5) { boostCrowdExcitement(0.3); triggerCrowdWave(); }

        // Screen shake (extra for uppercut)
        let shakeI = dmg * 0.3;
        if (attacker.currentPunch.name === 'UPPERCUT') shakeI *= 1.5;
        triggerShake(shakeI, dmg * 12);

        freezeFrames = Math.floor(dmg * 0.15);

        const px = hb.x + hb.w / 2, py = hb.y + hb.h / 2;
        spawnHitParticles(px, py, isHead ? '#ffff44' : '#ff8844', isHead ? 8 : 4);
        if (isHead && dmg > 15) flashAlpha = 0.3;

        // KO check (Host Authority)
        if (victim.hp <= 0 && (!isOnlineMode || PM.isHost)) {
          victim.hp = 0;
          // Slow-mo on final hit
          slowMoTimer = 1.0;
          slowMoScale = 0.2;
          gameState = 'KO'; koTimer = 3; koTarget = victim;
          triggerShake(8, 600);
          spawnHitParticles(px, py, '#ffffff', 20);
          cameraFlashTimer = 0.5;
          // Crowd goes absolutely wild on KO
          boostCrowdExcitement(1);
          triggerCrowdWave();
          spawnConfetti(40);
          for (let ti = 0; ti < 5; ti++) spawnThrownItem(60 + Math.random() * 520);
        }
      }
    }

    function triggerShake(intensity, duration) {
      shakeDur = Math.max(shakeDur, duration);
      shakeX = (Math.random() - 0.5) * intensity; shakeY = (Math.random() - 0.5) * intensity;
    }

    // ── Drawing ──
    function drawRing(ctx) {
      const now = performance.now();
      // Floor (Reflective wood/composite)
      const floorGrd = ctx.createLinearGradient(0, RING.y + RING.h, 0, H);
      floorGrd.addColorStop(0, '#1c1425'); floorGrd.addColorStop(1, '#0a0812');
      ctx.fillStyle = floorGrd;
      ctx.fillRect(0, RING.y + RING.h - 10, W, H - (RING.y + RING.h) + 20);

      // Dynamic floor reflections (subtle)
      ctx.globalAlpha = 0.15;
      [player, enemy].forEach(b => {
        const rx = b.x, ry = RING.y + RING.h + (b.groundY - (RING.y + RING.h)) * 0.5;
        const rGrd = ctx.createRadialGradient(rx, ry, 0, rx, ry, 40);
        rGrd.addColorStop(0, b.colors.main); rGrd.addColorStop(1, 'transparent');
        ctx.fillStyle = rGrd; ctx.beginPath(); ctx.ellipse(rx, ry, 30, 10, 0, 0, Math.PI * 2); ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Ring mat (High-end canvas texture)
      const matGrd = ctx.createLinearGradient(0, RING.y, 0, RING.y + RING.h);
      matGrd.addColorStop(0, '#2e1b3d'); matGrd.addColorStop(0.5, '#3a2248'); matGrd.addColorStop(1, '#2a1a35');
      ctx.fillStyle = matGrd;
      ctx.fillRect(RING.x, RING.y, RING.w, RING.h);

      // Fine mat texture (woven look)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 1;
      for (let tx = RING.x; tx < RING.x + RING.w; tx += 4) {
        ctx.beginPath(); ctx.moveTo(tx, RING.y); ctx.lineTo(tx, RING.y + RING.h); ctx.stroke();
      }

      // Center logo (Modern "KO" typography)
      ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.font = '900 80px "Outfit"'; ctx.textAlign = 'center';
      ctx.fillText('KO', RING_CENTER_X, RING.y + RING.h / 2 + 30);

      // Boundary lines
      ctx.strokeStyle = 'rgba(255,215,0,0.1)'; ctx.lineWidth = 3;
      ctx.strokeRect(RING.x + 5, RING.y + 5, RING.w - 10, RING.h - 10);

      // Posts (Metallic look)
      const posts = [[RING.x, RING.y], [RING.x + RING.w, RING.y], [RING.x, RING.y + RING.h], [RING.x + RING.w, RING.y + RING.h]];
      posts.forEach(([px, py], i) => {
        const pGrd = ctx.createLinearGradient(px - 8, py, px + 8, py);
        const pc = i < 2 ? '#333' : '#c8a860'; // Front posts gold, back dark
        pGrd.addColorStop(0, '#111'); pGrd.addColorStop(0.5, pc); pGrd.addColorStop(1, '#111');
        ctx.fillStyle = pGrd;
        ctx.beginPath();
        const rrx = px - 6, rry = py - 12, rrw = 12, rrh = 24, rad = 4;
        ctx.moveTo(rrx + rad, rry);
        ctx.lineTo(rrx + rrw - rad, rry); ctx.quadraticCurveTo(rrx + rrw, rry, rrx + rrw, rry + rad);
        ctx.lineTo(rrx + rrw, rry + rrh - rad); ctx.quadraticCurveTo(rrx + rrw, rry + rrh, rrx + rrw - rad, rry + rrh);
        ctx.lineTo(rrx + rad, rry + rrh); ctx.quadraticCurveTo(rrx, rry + rrh, rrx, rry + rrh - rad);
        ctx.lineTo(rrx, rry + rad); ctx.quadraticCurveTo(rrx, rry, rrx + rad, rry);
        ctx.fill();
      });

      // Ropes (Premium braided Look)
      ropeVibrationL *= 0.92; ropeVibrationR *= 0.92;
      for (let r = 0; r < 3; r++) {
        const ry = RING.y + 15 + r * 28;
        let lbx = 0, lby = 0, rbx = 0, rby = 0;
        const RZ = 40;
        [player, enemy].forEach(b => {
          const ld = b.x - RING.x; if (ld < RZ) { const t = Math.max(0, 1 - ld / RZ); lbx = Math.min(lbx, -t * 22); lby = Math.max(lby, t * 5); }
          const rd = (RING.x + RING.w) - b.x; if (rd < RZ) { const t = Math.max(0, 1 - rd / RZ); rbx = Math.max(rbx, t * 22); rby = Math.max(rby, t * 5); }
        });
        const vibL = Math.sin(now * 0.03 + r) * ropeVibrationL;
        const vibR = Math.sin(now * 0.03 + r + 1) * ropeVibrationR;

        // Rope Glow
        ctx.shadowColor = C.gold; ctx.shadowBlur = 4;
        ctx.strokeStyle = `rgba(200,160,80, ${0.4 + r * 0.2})`; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(RING.x + lbx, ry + lby + vibL);
        ctx.quadraticCurveTo(RING.x + RING.w / 2, ry - 2, RING.x + RING.w + rbx, ry + rby + vibR); ctx.stroke();
        ctx.shadowBlur = 0;

        // Braiding detail
        ctx.setLineDash([4, 4]); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(RING.x + lbx, ry + lby + vibL);
        ctx.quadraticCurveTo(RING.x + RING.w / 2, ry - 2, RING.x + RING.w + rbx, ry + rby + vibR); ctx.stroke();
        ctx.setLineDash([]);
      }

      // Volumetric Spotlight Beam
      const spotX = RING_CENTER_X + Math.sin(now * 0.0005) * 100;
      const spotGrd = ctx.createRadialGradient(spotX, RING.y - 100, 50, spotX, RING.y + 100, 400);
      spotGrd.addColorStop(0, 'rgba(255,245,220,0.15)');
      spotGrd.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = spotGrd;
      ctx.beginPath(); ctx.moveTo(spotX - 40, -50); ctx.lineTo(RING.x - 100, RING.y + RING.h + 100);
      ctx.lineTo(RING.x + RING.w + 100, RING.y + RING.h + 100); ctx.lineTo(spotX + 40, -50); ctx.fill();
    }

    // ── Crowd Excitement System ──
    let crowdExcitement = 0;       // 0 = calm, 1 = max hype
    let crowdExcitementTarget = 0;
    let crowdConfetti = [];        // confetti particles
    let crowdThrownItems = [];     // thrown cups/hats
    let crowdSigns = [];           // held-up signs
    let crowdWavePhase = -1;       // -1 = no wave, 0+ = wave progressing
    let lastCrowdUpdate = 0;

    function boostCrowdExcitement(amount) {
      crowdExcitementTarget = Math.min(1, crowdExcitementTarget + amount);
    }

    function triggerCrowdWave() {
      crowdWavePhase = 0;
    }

    function spawnConfetti(count) {
      for (let i = 0; i < count; i++) {
        crowdConfetti.push({
          x: Math.random() * W, y: -10 - Math.random() * 50,
          vx: (Math.random() - 0.5) * 2, vy: 0.5 + Math.random() * 1.5,
          rot: Math.random() * Math.PI * 2, rotV: (Math.random() - 0.5) * 0.2,
          color: ['#ff4444', '#44ff44', '#4444ff', '#ffdd44', '#ff44ff', '#44ffff', '#ffffff', '#ff8844'][Math.floor(Math.random() * 8)],
          size: 2 + Math.random() * 4, life: 3 + Math.random() * 3
        });
      }
    }

    function spawnThrownItem(fromX) {
      const types = ['🍺', '🎩', '🍿', '📱', '👟', '🧢'];
      crowdThrownItems.push({
        x: fromX, y: 155,
        vx: (Math.random() - 0.5) * 4 + (RING_CENTER_X - fromX) * 0.01,
        vy: -3 - Math.random() * 3,
        text: types[Math.floor(Math.random() * types.length)],
        life: 2.5, rot: 0, rotV: (Math.random() - 0.5) * 0.3
      });
    }

    function drawAudience(ctx) {
      const now = performance.now();
      const dt_crowd = Math.min(0.05, (now - lastCrowdUpdate) / 1000);
      lastCrowdUpdate = now;
      crowdExcitement += (crowdExcitementTarget - crowdExcitement) * 0.05;
      crowdExcitementTarget = Math.max(0, crowdExcitementTarget - 0.003);
      if (player && enemy) {
        const lowestHp = Math.min(player.hp / player.maxHp, enemy.hp / enemy.maxHp);
        if (lowestHp < 0.2) crowdExcitementTarget = Math.max(crowdExcitementTarget, 0.6);
        if (gameState === 'KO') crowdExcitementTarget = 1;
      }
      const exc = crowdExcitement;

      // ── Background Atmosphere (Distant crowd silhouettes) ──
      ctx.fillStyle = '#0a0812'; ctx.fillRect(0, 50, W, 120);

      const drawLayer = (count, yBase, color, scale, speed) => {
        ctx.fillStyle = color;
        for (let i = 0; i < count; i++) {
          const hx = (W / count) * i + Math.sin(now * 0.0002 * speed + i) * 10;
          const waveBob = crowdWavePhase >= 0 ? Math.max(0, Math.sin((crowdWavePhase - hx / W * 4) * Math.PI)) * 12 * scale : 0;
          const jump = (exc > 0.6 && Math.sin(now * 0.01 + i) > 0.8) ? exc * 10 * scale : 0;
          const hy = yBase - waveBob - jump + Math.sin(now * 0.002 + i) * 2;

          ctx.beginPath();
          ctx.ellipse(hx, hy, 6 * scale, 7 * scale, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(hx - 5 * scale, hy + 2 * scale, 10 * scale, 20 * scale);
        }
      };

      drawLayer(20, 80, 'rgba(10, 8, 20, 1)', 0.7, 1);  // Farthest
      drawLayer(15, 110, 'rgba(15, 12, 25, 1)', 0.85, 1.5); // Mid
      drawLayer(12, 145, 'rgba(20, 15, 35, 1)', 1.0, 2);  // Front

      // ── Dynamic Lens Flashes ──
      if (Math.random() < 0.005 + exc * 0.03) {
        const fx = Math.random() * W, fy = 60 + Math.random() * 80;
        const flareGrd = ctx.createRadialGradient(fx, fy, 0, fx, fy, 40);
        flareGrd.addColorStop(0, 'rgba(255,255,255,0.8)'); flareGrd.addColorStop(0.2, 'rgba(200,220,255,0.3)'); flareGrd.addColorStop(1, 'transparent');
        ctx.fillStyle = flareGrd; ctx.beginPath(); ctx.arc(fx, fy, 40, 0, Math.PI * 2); ctx.fill();
      }
    }

    function drawHUD(ctx) {
      const barW = 240, barH = 12, margin = 30;
      const leftBoxer = (isOnlineMode && !PM.isHost) ? enemy : player;
      const rightBoxer = (isOnlineMode && !PM.isHost) ? player : enemy;

      // Glassmorphism HUD Backgrounds
      const drawGlassPanel = (x, y, w, h, align) => {
        ctx.save();
        ctx.translate(align === 'right' ? x - w : x, y);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1;
        ctx.beginPath();
        const rad = 8;
        ctx.moveTo(rad, 0); ctx.lineTo(w - rad, 0); ctx.quadraticCurveTo(w, 0, w, rad);
        ctx.lineTo(w, h - rad); ctx.quadraticCurveTo(w, h, w - rad, h);
        ctx.lineTo(rad, h); ctx.quadraticCurveTo(0, h, 0, h - rad);
        ctx.lineTo(0, rad); ctx.quadraticCurveTo(0, 0, rad, 0);
        ctx.fill(); ctx.stroke();
        ctx.restore();
      };

      drawGlassPanel(margin - 10, 15, barW + 20, 75, 'left');
      drawGlassPanel(W - margin + 10, 15, barW + 20, 75, 'right');

      drawBar(ctx, margin, 35, barW, barH, leftBoxer.hp, leftBoxer.maxHp, hpColor(leftBoxer.hp, leftBoxer.maxHp), 'left');
      drawBar(ctx, margin, 52, barW * 0.7, 5, leftBoxer.stamina, leftBoxer.stamina, C.gold, 'left');
      drawName(ctx, margin, 75, leftBoxer.name, (leftBoxer === player ? C.p1 : C.p2), 'left');

      // Display Email
      if (isOnlineMode) {
        const leftEmail = PM.isHost ? PM.userEmail : PM.enemyEmail;
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.font = '500 10px "Outfit"'; ctx.textAlign = 'left';
        ctx.fillText(leftEmail, margin, 28);
      }

      const p2x = W - margin;
      drawBar(ctx, p2x, 35, barW, barH, rightBoxer.hp, rightBoxer.maxHp, hpColor(rightBoxer.hp, rightBoxer.maxHp), 'right');
      drawBar(ctx, p2x, 52, barW * 0.7, 5, rightBoxer.stamina, rightBoxer.stamina, C.gold, 'right');
      drawName(ctx, p2x, 75, rightBoxer.name, (rightBoxer === player ? C.p1 : C.p2), 'right');

      // Display Email
      if (isOnlineMode) {
        const rightEmail = PM.isHost ? PM.enemyEmail : PM.userEmail;
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.font = '500 10px "Outfit"'; ctx.textAlign = 'right';
        ctx.fillText(rightEmail, p2x, 28);
      }

      // Center Clock
      ctx.fillStyle = '#fff'; ctx.font = '900 22px "Outfit"'; ctx.textAlign = 'center';
      ctx.fillText('RD ' + roundNumber, W / 2, 40);
      ctx.font = '900 56px "Outfit"';
      ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10;
      ctx.fillText(Math.ceil(roundTimer).toString(), W / 2, 90);
      ctx.shadowBlur = 0;

      // Ability Charge Bar (Only for Chester)
      [leftBoxer, rightBoxer].forEach((b, i) => {
        if (b.name === 'CHESTER') {
          const sideW = 120, sideH = 6;
          const sx = i === 0 ? margin : W - margin - sideW;
          const sy = 65;
          ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(sx, sy, sideW, sideH);
          ctx.fillStyle = b.abilityCharge >= 100 ? '#fff700' : '#ffcc00';
          ctx.fillRect(sx, sy, (b.abilityCharge / 100) * sideW, sideH);
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(sx, sy, sideW, sideH);
          ctx.fillStyle = '#fff'; ctx.font = '600 8px "Outfit"'; ctx.textAlign = i === 0 ? 'left' : 'right';
          ctx.fillText(b.abilityCharge >= 100 ? 'Q - READY!' : 'CLUCK FURY', i === 0 ? sx : sx + sideW, sy - 4);

          // Central Pulse Instruction
          if (b.abilityCharge >= 100 && b.isPlayer) {
            ctx.save();
            const pulse = 0.6 + Math.sin(Date.now() * 0.006) * 0.4;
            ctx.globalAlpha = pulse;
            ctx.shadowBlur = 15; ctx.shadowColor = '#fff700';
            ctx.fillStyle = '#fff700'; ctx.font = '900 24px "Outfit"'; ctx.textAlign = 'center';
            ctx.fillText('PRESS Q TO ACTIVATE', W / 2, 140);
            ctx.restore();
          }
        }
      });

    }

    function drawBar(ctx, x, y, w, h, val, max, color, align) {
      const bx = align === 'right' ? x - w : x, pct = Math.max(0, val / max);

      // Bar Track
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(bx, y, w, h);

      // Value Fill with Gradient
      const fillW = w * pct;
      const fx = align === 'right' ? x - fillW : x;
      const barGrd = ctx.createLinearGradient(fx, y, fx + fillW, y);
      barGrd.addColorStop(0, color); barGrd.addColorStop(1, '#fff');
      ctx.fillStyle = barGrd;
      ctx.fillRect(fx, y, fillW, h);

      // Reflection
      ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.fillRect(bx, y, w, h / 2);
    }
    function drawName(ctx, x, y, name, color, align) {
      ctx.font = '900 16px "Outfit"'; ctx.fillStyle = '#fff'; ctx.textAlign = align;
      ctx.fillText(name.toUpperCase(), x, y);
      ctx.fillStyle = color;
      ctx.fillRect(align === 'left' ? x : x - 40, y + 4, 40, 2);
    }
    function hpColor(hp, max) { const p = hp / max; return p > 0.5 ? C.hpGreen : p > 0.25 ? C.hpYellow : C.hpRed; }

    function drawVignette(ctx) {
      const grd = ctx.createRadialGradient(W / 2, H / 2, 100, W / 2, H / 2, 380);
      grd.addColorStop(0, 'rgba(0,0,0,0)');
      grd.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, W, H);
    }

    function drawTitle(ctx) {
      ctx.fillStyle = C.bg; ctx.fillRect(0, 0, W, H);
      drawAudience(ctx); drawRing(ctx);
      ctx.textAlign = 'center';

      // Modern Title Typography
      ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 15;
      ctx.fillStyle = C.gold; ctx.font = '900 85px "Outfit"';
      ctx.fillText('KNOCKOUT', W / 2, 120);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.8; ctx.font = '700 18px "Outfit"';
      ctx.fillText('CINEMATIC BOXING EXPERIENCE', W / 2, 155);
      ctx.globalAlpha = 1;

      if (!showPartyMenu) {
        document.getElementById('party-overlay').style.display = 'flex';
        document.getElementById('party-menu').style.display = 'flex';
        document.getElementById('waiting-screen').style.display = 'none';
        showPartyMenu = true;
      }

      // Instruction Bar
      const instY = H - 35;
      ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(0, instY - 20, W, 40);
      ctx.fillStyle = '#aaa'; ctx.font = '600 13px "Outfit"';
      if (CHARACTERS[selectedCharIdx] && CHARACTERS[selectedCharIdx].name === 'CHESTER') {
        ctx.fillText('WASD MOVE • LMB JAB (BARRAGE) • ERQF PUNCH • S BLOCK • SPACE JUMP • Q CLUCK FURY', W / 2, instY + 5);
      } else {
        ctx.fillText('WASD MOVE  •  LMB/ERQF PUNCH  •  S BLOCK  •  SPACE JUMP', W / 2, instY + 5);
      }

      drawVignette(ctx);
    }

    // ── Character Selection Screen ──
    function drawCharSelect(ctx) {
      ctx.fillStyle = C.bg; ctx.fillRect(0, 0, W, H);
      drawAudience(ctx);

      const now = performance.now();

      // Title
      ctx.textAlign = 'center';
      ctx.fillStyle = C.gold; ctx.font = '16px "Press Start 2P"';
      ctx.fillText('SELECT YOUR FIGHTER', W / 2, 40);

      const cardW = 180, cardH = 280, gap = 15;
      const totalW = CHARACTERS.length * cardW + (CHARACTERS.length - 1) * gap;

      // Clamp target scroll
      const maxScroll = Math.max(0, totalW - (W - 80)); // 40px padding each side
      charSelectTargetScroll = Math.max(0, Math.min(maxScroll, charSelectTargetScroll));

      const startX = (W - totalW) / 2;
      // If we have more characters than fit, start from the left instead of centering
      const drawStartX = totalW > W - 80 ? 40 : startX;

      ctx.save();
      ctx.translate(-charSelectScroll, 0);

      for (let i = 0; i < CHARACTERS.length; i++) {
        const ch = CHARACTERS[i];
        const cx = drawStartX + i * (cardW + gap);
        const cy = 55;
        const isSelected = i === selectedCharIdx;
        const isHover = charHoverIdx === i;
        const isEnemyChoice = isOnlineMode && PM.enemyCharIdx === i;
        const isLocked = isCharLocked(ch);

        // Card background
        ctx.fillStyle = isSelected ? 'rgba(255,220,68,0.15)' : 'rgba(20,10,35,0.85)';
        ctx.fillRect(cx, cy, cardW, cardH);

        // Card border (animated glow for selected)
        if (isSelected) {
          ctx.strokeStyle = C.gold; ctx.lineWidth = 3;
          ctx.shadowColor = C.gold; ctx.shadowBlur = 10 + Math.sin(now * 0.005) * 5;
        } else if (isEnemyChoice) {
          ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
        } else if (isLocked) {
          ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.shadowBlur = 0;
        } else if (isHover) {
          ctx.strokeStyle = '#888'; ctx.lineWidth = 2; ctx.shadowBlur = 0;
        } else {
          ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.shadowBlur = 0;
        }
        ctx.strokeRect(cx, cy, cardW, cardH);
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;

        // P2 indicator
        if (isEnemyChoice) {
          ctx.fillStyle = '#ff4444'; ctx.font = '8px "Press Start 2P"';
          ctx.fillText(PM.enemyReady ? 'P2 READY' : 'P2 PICKING', cx + cardW / 2, cy + cardH - 10);
        }

        // Character name
        ctx.fillStyle = isLocked ? '#666' : (isSelected ? C.gold : ch.colors.main);
        ctx.font = '900 24px "Outfit"'; ctx.textAlign = 'center';
        ctx.fillText(ch.name, cx + cardW / 2, cy + 30);

        // Title
        ctx.fillStyle = '#fff'; ctx.globalAlpha = isLocked ? 0.3 : 0.6; ctx.font = '700 12px "Outfit"';
        ctx.fillText(ch.title, cx + cardW / 2, cy + 48);
        ctx.globalAlpha = 1;

        // Character preview (silhouette/body)
        const sc = 2.0; // scale for preview
        const bob = Math.sin(now * 0.003 + i) * 5;
        ctx.save();
        ctx.translate(cx + cardW / 2, cy + 130 + bob);

        // Apply grayscale if locked
        if (isLocked) {
          // Simplistic grayscale by reducing alpha or drawing a silhouette
          ctx.globalAlpha = 0.4;
        }

        // Shadow base
        const shdGrd = ctx.createRadialGradient(0, 30, 0, 0, 30, 25);
        shdGrd.addColorStop(0, 'rgba(0,0,0,0.4)'); shdGrd.addColorStop(1, 'transparent');
        ctx.fillStyle = shdGrd; ctx.beginPath(); ctx.ellipse(0, 30, 25, 8, 0, 0, Math.PI * 2); ctx.fill();

        // ── Anatomy Preview ──
        const sk = ch.colors.skin;
        const mainC = ch.colors.main;
        const skShd = ch.colors.skinShd || sk;
        const gc = ch.colors.glove;
        const hairC = ch.colors.hair || '#000';

        ctx.lineCap = 'round'; ctx.lineJoin = 'round';

        // Simple but high-fidelity preview body
        // Legs
        ctx.strokeStyle = skShd; ctx.lineWidth = 12 * sc;
        ctx.beginPath(); ctx.moveTo(-6 * sc, 10); ctx.lineTo(-10 * sc, 30); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(6 * sc, 10); ctx.lineTo(10 * sc, 30); ctx.stroke();

        // Torso
        ctx.fillStyle = sk;
        ctx.beginPath(); ctx.moveTo(-12 * sc, 10); ctx.lineTo(12 * sc, 10);
        ctx.lineTo(14 * sc, -25 * sc); ctx.lineTo(-14 * sc, -25 * sc); ctx.fill();

        // Shorts
        ctx.fillStyle = mainC; ctx.fillRect(-13 * sc, -2 * sc, 26 * sc, 14 * sc);

        // Arms
        ctx.strokeStyle = sk; ctx.lineWidth = 10 * sc;
        ctx.beginPath(); ctx.moveTo(-14 * sc, -22 * sc); ctx.lineTo(-20 * sc, -5 * sc); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(14 * sc, -22 * sc); ctx.lineTo(20 * sc, -5 * sc); ctx.stroke();

        // Gloves
        ctx.fillStyle = gc;
        ctx.beginPath(); ctx.arc(-20 * sc, -5 * sc, 8 * sc, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(20 * sc, -5 * sc, 8 * sc, 0, Math.PI * 2); ctx.fill();

        // Head
        const hRad = 12 * sc;
        ctx.fillStyle = sk; ctx.beginPath(); ctx.arc(0, -32 * sc, hRad, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = hairC;
        ctx.beginPath(); ctx.arc(0, -34 * sc, hRad + 1, Math.PI, 0); ctx.fill();

        ctx.restore();

        // Lock Icon if restricted
        if (isLocked) {
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(cx, cy, cardW, cardH);

          ctx.fillStyle = '#fff'; ctx.font = '32px "serif"';
          ctx.textAlign = 'center';
          ctx.fillText('🔒', cx + cardW / 2, cy + cardH / 2 + 10);

          ctx.fillStyle = '#ff4444'; ctx.font = '700 10px "Outfit"';
          ctx.fillText('LOCKED', cx + cardW / 2, cy + cardH / 2 + 40);
        }

        // Description
        ctx.fillStyle = '#fff'; ctx.globalAlpha = isLocked ? 0.2 : 1; ctx.font = '400 13px "Outfit"'; ctx.textAlign = 'center';
        ctx.fillText(ch.desc, cx + cardW / 2, cy + 205);
        ctx.globalAlpha = 1;

        // Stats UI
        const statNames = Object.keys(ch.statBars);
        const barStartY = cy + 225;
        statNames.forEach((sn, si) => {
          const sv = ch.statBars[sn];
          const bsy = barStartY + si * 14;
          ctx.fillStyle = isLocked ? 'rgba(255,255,255,0.2)' : 'rgba(255,255,255,0.5)'; ctx.font = '600 11px "Outfit"'; ctx.textAlign = 'left';
          ctx.fillText(sn.toUpperCase(), cx + 15, bsy + 4);

          // Custom stat segment drawing
          for (let seg = 0; seg < 5; seg++) {
            ctx.fillStyle = seg < sv ? (isLocked ? '#444' : ch.colors.main) : 'rgba(255,255,255,0.1)';
            const segX = cx + 80 + seg * 18;
            ctx.fillRect(segX, bsy - 3, 14, 6);
          }
        });
      }

      // Instructions
      ctx.fillStyle = '#666'; ctx.font = '6px "Press Start 2P"'; ctx.textAlign = 'center';
      ctx.fillText('CLICK TO SELECT  •  PRESS SPACE OR CLICK START TO FIGHT', W / 2, H - 20);

      // Start button
      const btnW = 160, btnH = 24;
      const btnX = W / 2 - btnW / 2, btnY = H - 55;
      const readyToStart = !isOnlineMode || (PM.playerReady && PM.enemyReady);

      ctx.fillStyle = isOnlineMode && PM.playerReady ? '#44ff44' : CHARACTERS[selectedCharIdx].colors.main;
      ctx.fillRect(btnX, btnY, btnW, btnH);
      ctx.strokeStyle = C.gold; ctx.lineWidth = 2;
      ctx.strokeRect(btnX, btnY, btnW, btnH);
      ctx.fillStyle = '#000'; ctx.font = '8px "Press Start 2P"'; ctx.textAlign = 'center';

      let btnText = 'START FIGHT';
      if (isOnlineMode) {
        if (PM.playerReady && PM.enemyReady) btnText = 'GET READY!';
        else if (PM.playerReady) btnText = 'WAITING...';
        else btnText = 'READY UP';
      }
      ctx.fillText(btnText, W / 2, btnY + 16);

      // Store button region for click detection
      charSelectBtnRegion = { x: btnX, y: btnY, w: btnW, h: btnH };

      // Test Mode button (Chester only) — beside START FIGHT
      const isChester = CHARACTERS[selectedCharIdx] && CHARACTERS[selectedCharIdx].name === 'CHESTER' && !isCharLocked(CHARACTERS[selectedCharIdx]);
      if (isChester && !isOnlineMode) {
        const tbW = 100, tbH = btnH;
        const tbX = btnX + btnW + 10, tbY = btnY;
        const pulse = 0.7 + Math.sin(performance.now() * 0.005) * 0.3;
        ctx.save();
        ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10 * pulse;
        ctx.fillStyle = `rgba(200, 0, 0, ${pulse})`; ctx.fillRect(tbX, tbY, tbW, tbH);
        ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2; ctx.strokeRect(tbX, tbY, tbW, tbH);
        ctx.restore();
        ctx.fillStyle = '#fff'; ctx.font = '700 7px "Press Start 2P"'; ctx.textAlign = 'center';
        ctx.fillText('TEST MODE', tbX + tbW / 2, tbY + 16);
        charSelectTestBtnRegion = { x: tbX, y: tbY, w: tbW, h: tbH };
      } else {
        charSelectTestBtnRegion = null;
      }

      drawVignette(ctx);
      ctx.restore();

      // Scroll indicators (if overflow)
      if (maxScroll > 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        if (charSelectScroll > 20) { // Left arrow
          ctx.beginPath(); ctx.moveTo(25, H / 2); ctx.lineTo(40, H / 2 - 15); ctx.lineTo(40, H / 2 + 15); ctx.fill();
        }
        if (charSelectScroll < maxScroll - 20) { // Right arrow
          ctx.beginPath(); ctx.moveTo(W - 25, H / 2); ctx.lineTo(W - 40, H / 2 - 15); ctx.lineTo(W - 40, H / 2 + 15); ctx.fill();
        }
      }
    }

    // Click regions for character select
    let charHoverIdx = -1;
    let charSelectBtnRegion = null;
    let charSelectTestBtnRegion = null;

    function drawKO(ctx) {
      ctx.save();
      ctx.textAlign = 'center';

      // Backdrop blur-ish effect
      ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, W, H);

      // KO Banner
      ctx.fillStyle = '#ff4444'; ctx.font = '900 120px "Outfit"';
      ctx.shadowColor = '#000'; ctx.shadowBlur = 20;
      ctx.fillText('K.O.', W / 2, H / 2);
      ctx.shadowBlur = 0;

      const winner = koTarget === enemy ? player.name : enemy.name;
      ctx.fillStyle = C.gold; ctx.font = '900 24px "Outfit"';
      ctx.fillText(winner.toUpperCase() + ' WINS THE ROUND!', W / 2, H / 2 + 50);

      // Victory text for winner
      victoryTimer += 0.05;
      const wBox = koTarget === enemy ? player : enemy;
      if (wBox) {
        const vy = Math.abs(Math.sin(victoryTimer * 3.5)) * 8;
        ctx.fillStyle = C.gold; ctx.font = '900 18px "Outfit"';
        ctx.fillText('VICTORY', wBox.x, wBox.y - 100 - vy);
      }

      if (koTimer <= 0) {
        ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.7; ctx.font = '600 16px "Outfit"';
        ctx.fillText('PRESS SPACE FOR NEXT ROUND', W / 2, H - 50);
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }

    // ── Main Loop ──
    let lastTime = 0;
    function gameLoop(timestamp) {
      requestAnimationFrame(gameLoop);
      let dt = Math.min((timestamp - lastTime) / 1000, 0.05);
      const dt_real = dt; // keep real dt for cutscenes
      lastTime = timestamp;

      // Cutscene logic
      if (cutsceneActive) {
        cutsceneTimer -= dt_real;
        if (cutsceneTimer <= 0) {
          cutsceneActive = false;
          cameraZoom = 1.0;
        } else {
          // Cinematic effects
          const progress = 1 - (cutsceneTimer / 1.5);
          if (progress < 0.2) cameraZoom = 1.0 + progress * 5; // Zoom in
          else if (progress < 0.8) cameraZoom = 2.0; // Hold
          else cameraZoom = 2.0 - (progress - 0.8) * 5; // Zoom out

          if (cutsceneBoxer) {
            cameraTargetX = cutsceneBoxer.x;
            cameraTargetY = cutsceneBoxer.y - 40;
          }
          // Lerp camera
          cameraX += (cameraTargetX - cameraX) * 0.15;
          cameraY += (cameraTargetY - cameraY) * 0.15;
        }
        dt = 0; // Pause game logic during cutscene
      } else {
        cameraZoom += (1.0 - cameraZoom) * 0.1;
        cameraX += (W / 2 - cameraX) * 0.1;
        cameraY += (H / 2 - cameraY) * 0.1;
      }

      // Slow-mo
      if (slowMoTimer > 0) { slowMoTimer -= dt; dt *= slowMoScale; slowMoScale = Math.min(1, slowMoScale + 0.01); }

      if (gameState === 'TITLE') {
        drawTitle(ctx);
        return;
      }

      if (gameState === 'CHARSELECT') {
        // Smooth scroll lerp
        charSelectScroll += (charSelectTargetScroll - charSelectScroll) * 0.15;
        drawCharSelect(ctx);
        return;
      }

      if (gameState === 'DISCONNECTED') {
        drawTitle(ctx);
        return;
      }

      if (freezeFrames > 0) { freezeFrames--; return; }

      // Camera flash decay
      if (cameraFlashTimer > 0) cameraFlashTimer -= dt;

      if (gameState === 'FIGHTING') {
        roundTimerAccum += dt;
        if (roundTimerAccum >= 1) { roundTimer--; roundTimerAccum -= 1; }
        if (roundTimer <= 0 && (!isOnlineMode || PM.isHost)) {
          gameState = 'KO'; koTimer = 2;
          koTarget = player.hp >= enemy.hp ? enemy : player;
          slowMoTimer = 0.5; slowMoScale = 0.3;
        }

        // Combo timer decay
        if (comboTimer > 0) comboTimer -= dt;
        else comboCount = 0;

        // Player mouse aim → aimY based on mouse position relative to player head
        const playerScreenY = player.headY;
        player.aimY = Math.max(-1, Math.min(1, (mouseY - playerScreenY) / 40));

        // Compute mouse aim angle for arm pointing (from shoulder to mouse)
        const shoulderScreenX = player.x + player.facing * 8;
        const shoulderScreenY = player.y - 32 + Math.sin(player.bobPhase) * 2 + player.breathAnim;
        player.mouseAimAngle = Math.atan2(mouseY - shoulderScreenY, mouseX - shoulderScreenX);

        // Player input
        player.blocking = false;
        if (keys['KeyA'] || keys['ArrowLeft']) player.move(-1);
        if (keys['KeyD'] || keys['ArrowRight']) player.move(1);
        if (keys['KeyW'] || keys['ArrowUp']) player.moveZ(-1);  // move up in ring
        if (keys['KeyS'] || keys['ArrowDown'] || rmbDown) {
          player.blocking = true;
          if (!player._blockStarted) { player.blockStartTime = performance.now(); player._blockStarted = true; }
        } else { player._blockStarted = false; }
        if (keys['Space']) { player.jump(); keys['Space'] = false; }

        // Dash punch: double-tap direction + LMB
        if (dashPunchReady && mouseDown) {
          player.punch('dashpunch');
          dashPunchReady = false; mouseDown = false;
        } else {
          if (mouseDown) { player.punch('jab'); mouseDown = false; }
        }
        if (keys['KeyE']) {
          if (player.barrageHits > 0) { player.barrageHits = 0; player.attacking = false; player.currentPunch = null; player.punchArmExt = 0; player.attackCooldown = 0; }
          player.punch('cross'); keys['KeyE'] = false;
        }
        if (keys['KeyR']) {
          if (player.barrageHits > 0) { player.barrageHits = 0; player.attacking = false; player.currentPunch = null; player.punchArmExt = 0; player.attackCooldown = 0; }
          player.punch('hook'); keys['KeyR'] = false;
        }
        if (keys['KeyF']) {
          if (player.barrageHits > 0) { player.barrageHits = 0; player.attacking = false; player.currentPunch = null; player.punchArmExt = 0; player.attackCooldown = 0; }
          player.punch('uppercut'); keys['KeyF'] = false;
        }
        if (keys['KeyQ']) {
          if (player.barrageHits > 0) { player.barrageHits = 0; player.attacking = false; player.currentPunch = null; player.punchArmExt = 0; player.attackCooldown = 0; }
          player.punch('bodyshot'); keys['KeyQ'] = false;
        }
        // Reset dash if no direction held
        if (!keys['KeyA'] && !keys['KeyD']) dashPunchReady = false;

        // Online guest: send input
        if (isOnlineMode && !PM.isHost) {
          const inp = {
            left: keys['KeyA'] || keys['ArrowLeft'] ? 1 : 0,
            right: keys['KeyD'] || keys['ArrowRight'] ? 1 : 0,
            block: keys['KeyS'] || keys['ArrowDown'] || rmbDown ? 1 : 0,
            up: keys['KeyW'] || keys['ArrowUp'] ? 1 : 0,
            aimY: player.aimY,
            ac: Object.assign({}, guestActionCounts)
          };
          PM.sendInput(inp);
        }

        // Apply received state from Host (Guest perspective mapping handled inside)
        if (isOnlineMode && !PM.isHost && remoteGameState) {
          applyReceivedGameState(remoteGameState);
        }

        // Host: Apply Guest inputs
        if (isOnlineMode && PM.isHost) {
          applyGuestInput(enemy, PM.lastGuestInput);
        }

        // AI logic (Offline or Host vs AI) — skip in test mode
        if (!isOnlineMode && !isTestMode) {
          AI.update(dt, enemy, player);
        }

        // Test mode: keep dummy at max HP
        if (isTestMode) {
          enemy.hp = enemy.maxHp;
        }

        // Common Simulation (Movement, Facing, Hitbox update)
        player.facing = enemy.x > player.x ? 1 : -1;
        enemy.facing = player.x > enemy.x ? 1 : -1;
        player.update(dt); enemy.update(dt);

        // Host is source of truth for hits, but Guest also runs checks for immediate local effects
        checkHits();
        updateParticles(dt);

        // Host: sync state to guest
        if (isOnlineMode && PM.isHost) {
          syncCounter++;
          if (syncCounter >= SYNC_RATE) {
            PM.sendGameState(serializeGameState());
            syncCounter = 0;
          }
        }
      }

      if (gameState === 'KO') {
        koTimer -= dt;
        updateParticles(dt);
        if (koTimer <= 0 && keys['Space']) {
          const winner = koTarget === enemy ? player : enemy;
          winner.score++; roundNumber++; resetRound();
          keys['Space'] = false;
        }
      }

      // Screen shake
      if (shakeDur > 0) {
        shakeDur -= dt * 1000;
        shakeX = (Math.random() - 0.5) * (shakeDur / 100);
        shakeY = (Math.random() - 0.5) * (shakeDur / 100);
      } else { shakeX = 0; shakeY = 0; }

      if (flashAlpha > 0) flashAlpha -= dt * 2;

      // ── Draw ──
      ctx.save();
      // Apply Camera
      ctx.translate(W / 2, H / 2);
      ctx.scale(cameraZoom, cameraZoom);
      ctx.translate(-cameraX + shakeX, -cameraY + shakeY);

      ctx.fillStyle = C.bg; ctx.fillRect(cameraX - W / 2 - 10, cameraY - H / 2 - 10, W + 20, H + 20);
      drawAudience(ctx);
      drawRing(ctx);
      const fighters = [player, enemy].sort((a, b) => a.y - b.y);
      for (const f of fighters) f.draw(ctx);
      drawParticles(ctx);
      drawHUD(ctx);

      // Flash overlay
      if (flashAlpha > 0) {
        ctx.fillStyle = 'rgba(255,255,255,' + flashAlpha + ')';
        ctx.fillRect(0, 0, W, H);
      }

      // Vignette
      drawVignette(ctx);

      ctx.restore();

      // UI (Not affected by camera scale)
      if (cutsceneActive) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = '#fff700'; ctx.font = '900 60px "Outfit"'; ctx.textAlign = 'center';
        ctx.shadowColor = '#000'; ctx.shadowBlur = 20;
        ctx.fillText('CLUCK FURY', W / 2, H / 2);
        ctx.shadowBlur = 0;
      }


      if (gameState === 'KO') drawKO(ctx);
    }

    // ── Party Manager (PeerJS ─ no server needed!) ──
    // ── Party Manager (PeerJS ─ no server needed!) ──
    const PM = {
      peer: null, conn: null, isHost: false,
      lastGuestInput: {}, connected: false,
      syncInterval: null,
      enemyCharIdx: 0,
      enemyReady: false,
      playerReady: false,
      userEmail: '',
      enemyEmail: '',

      init() {
        this.peer = new Peer();
        this.peer.on('open', (id) => { console.log('My Peer ID:', id); });
        this.peer.on('connection', (c) => this.handleIncoming(c));
      },

      handleIncoming(c) {
        if (this.conn) { c.close(); return; }
        this.conn = c;
        this.isHost = true;
        this.setupConn();

        const user = localStorage.getItem('knockout_user');
        this.userEmail = user || 'GUEST';

        this.conn.on('open', () => {
          this.connected = true;
          this.conn.send({
            type: 'welcome',
            charIdx: selectedCharIdx,
            email: this.userEmail
          });
          startOnlineGame();
          // Host: sync state to guest
          this.syncInterval = setInterval(() => {
            if ((gameState === 'FIGHTING' || gameState === 'KO') && this.conn && this.conn.open) {
              this.sendGameState(serializeGameState());
            }
          }, 50);
        });
      },

      async createParty(pw) {
        if (!pw.trim()) { setStatus('ENTER A ROOM CODE'); return false; }
        const roomId = 'knockout-party-' + pw.trim().toLowerCase();
        setStatus('CREATING ROOM...');

        // Destroy old peer if exists
        if (this.peer) this.peer.destroy();

        return new Promise((resolve) => {
          this.peer = new Peer(roomId);
          this.isHost = true;

          this.peer.on('open', () => {
            setStatus('ROOM: ' + pw.toUpperCase());
            resolve(true);
          });

          this.peer.on('connection', (c) => this.handleIncoming(c));

          this.peer.on('error', (err) => {
            if (err.type === 'unavailable-id') {
              setStatus('ROOM CODE TAKEN — TRY ANOTHER');
            } else {
              setStatus('ERROR: ' + err.message);
            }
            resolve(false);
          });
        });
      },

      async joinParty(pw) {
        if (!pw.trim()) { setStatus('ENTER A ROOM CODE'); return false; }
        const targetId = 'knockout-party-' + pw.trim().toLowerCase();
        setStatus('CONNECTING...');

        if (this.peer) this.peer.destroy();

        return new Promise((resolve) => {
          this.peer = new Peer(); // Guest gets random ID
          this.isHost = false;

          this.peer.on('open', () => {
            this.conn = this.peer.connect(targetId, { reliable: true });
            this.setupConn();

            const user = localStorage.getItem('knockout_user');
            this.userEmail = user || 'GUEST';

            this.conn.on('open', () => {
              this.connected = true;
              startOnlineGame();
              this.conn.send({
                type: 'greet',
                charIdx: selectedCharIdx,
                email: this.userEmail
              });
              resolve(true);
            });

            // Timeout
            setTimeout(() => {
              if (!this.connected) {
                setStatus('ROOM NOT FOUND — CHECK THE CODE');
                resolve(false);
              }
            }, 8000);
          });

          this.peer.on('error', (err) => {
            setStatus('ERROR: ' + err.message);
            resolve(false);
          });
        });
      },

      setupConn() {
        this.conn.on('data', (data) => {
          if (data.type === 'welcome' || data.type === 'greet') {
            this.enemyCharIdx = data.charIdx;
            this.enemyEmail = data.email || 'GUEST';
            if (data.type === 'greet') {
              this.conn.send({
                type: 'welcome',
                charIdx: selectedCharIdx,
                email: this.userEmail
              });
            }
          }
          if (data.type === 'state') remoteGameState = data.data;
          if (data.type === 'char_update') {
            this.enemyCharIdx = data.idx;
            this.enemyEmail = data.email || this.enemyEmail;
          }
          if (data.type === 'ready') this.enemyReady = data.ready;
          if (data.type === 'input') {
            // Guest input for Host to apply
            this.lastGuestInput = data.data;
          }
          if (data.type === 'disconnect') this.leave();
        });

        this.conn.on('close', () => this.leave());
      },

      sendInput(inp) {
        if (this.conn && this.conn.open && !this.isHost) {
          this.conn.send({ type: 'input', data: inp });
        }
      },

      sendGameState(s) {
        if (this.conn && this.conn.open && this.isHost) {
          this.conn.send({ type: 'state', data: s });
        }
      },

      leave() {
        if (this.syncInterval) { clearInterval(this.syncInterval); this.syncInterval = null; }
        if (this.conn) { this.conn.close(); this.conn = null; }
        if (this.peer) { this.peer.destroy(); this.peer = null; }
        this.isHost = false; this.connected = false;
        this.lastGuestInput = {}; isOnlineMode = false; remoteGameState = null;
        this.enemyEmail = '';
      }
    };

    function setStatus(msg) { document.getElementById('party-status').textContent = msg; }

    function startOnlineGame() {
      isOnlineMode = true; showPartyMenu = false;
      document.getElementById('party-overlay').style.display = 'none';
      // Reset ready states and character sync
      PM.enemyReady = false; PM.playerReady = false; PM.enemyCharIdx = 0;
      // Go to character select first — startGame() handles the rest
      gameState = 'CHARSELECT';
    }

    function serializeGameState() {
      return {
        p1: sBoxer(player), p2: sBoxer(enemy), rn: roundNumber, rt: roundTimer,
        gs: gameState, ko: koTarget === player ? 'p1' : koTarget === enemy ? 'p2' : null,
        cc: comboCount, ct: comboTimer, la: lastAttacker === player ? 'p1' : 'p2',
        sx: shakeX, sy: shakeY, sd: shakeDur, fa: flashAlpha
      };
    }
    function sBoxer(b) {
      return {
        x: b.x | 0, y: b.y | 0, hp: Math.round(b.hp * 10) / 10, st: Math.round(b.stamina * 10) / 10,
        f: b.facing, a: b.attacking ? 1 : 0, pn: b.currentPunch ? b.currentPunch.name : 0,
        pe: Math.round(b.punchArmExt * 100) / 100, bl: b.blocking ? 1 : 0, hf: b.hitFlash > 0 ? 1 : 0,
        hs: Math.round(b.headSnapBack * 10) / 10, sn: b.stunTimer > 0 ? 1 : 0,
        bp: Math.round(b.bobPhase * 10) / 10, br: Math.round(b.breathPhase * 10) / 10,
        sp: Math.round(b.staggerPhase * 10) / 10, vy: Math.round(b.vy * 10) / 10,
        gr: b.isGrounded ? 1 : 0, kb: Math.round(b.knockbackVx * 10) / 10, sc: b.score,
        bc: Math.round(b.abilityCharge), cf: b.isCluckFury ? 1 : 0
      };
    }
    function applyReceivedGameState(gs) {
      if (!gs || !gs.p1 || !gs.p2) return;
      if (PM.isHost) {
        // Host should theoretically not call this as they are the source, but for safety:
        dBoxer(player, gs.p1); dBoxer(enemy, gs.p2);
        koTarget = gs.ko === 'p1' ? player : gs.ko === 'p2' ? enemy : null;
        // Guest: Swap P1 (Host) and P2 (Guest) to match local perspective
        dBoxer(player, gs.p2, true); // true = local player prediction
        dBoxer(enemy, gs.p1, false);
        koTarget = gs.ko === 'p2' ? player : gs.ko === 'p1' ? enemy : null;
      }
      roundNumber = gs.rn; roundTimer = gs.rt;
      if (gs.gs === 'KO' && gameState !== 'KO') { gameState = 'KO'; koTimer = 3; }
      else if (gs.gs === 'FIGHTING') gameState = 'FIGHTING';
      comboCount = gs.cc || 0; comboTimer = gs.ct || 0;
      lastAttacker = (gs.la === 'p1' && PM.isHost) || (gs.la === 'p2' && !PM.isHost) ? player : enemy;
      shakeX = gs.sx || 0; shakeY = gs.sy || 0; shakeDur = gs.sd || 0; flashAlpha = gs.fa || 0;
    }
    function dBoxer(b, s, isLocal) {
      // For local players in online mode, trust local physics to prevent rubberbanding
      // Only snap if the distance is too large (> 50px)
      if (isLocal && isOnlineMode) {
        const dist = Math.abs(b.x - s.x);
        if (dist > 50) b.x = s.x; // snap if way off
        b.hp = s.hp; b.stamina = s.st; // Stats are always authoritative
        b.score = s.sc;
        b.abilityCharge = s.bc || 0; b.isCluckFury = !!s.cf;
        return;
      }

      // Remote character: Lerp position for smoothness
      b.x += (s.x - b.x) * 0.3; b.y += (s.y - b.y) * 0.3;
      b.hp = s.hp; b.stamina = s.st; b.facing = s.f;
      b.attacking = !!s.a; b.currentPunch = s.pn ? PUNCHES_BY_NAME[s.pn] : null;
      b.punchArmExt = s.pe; b.blocking = !!s.bl; b.hitFlash = s.hf ? 0.1 : 0;
      b.headSnapBack = s.hs; b.stunTimer = s.sn ? 0.2 : 0;
      b.bobPhase = s.bp; b.breathPhase = s.br; b.staggerPhase = s.sp;
      b.vy = s.vy; b.isGrounded = !!s.gr; b.knockbackVx = s.kb; b.score = s.sc;
      b.abilityCharge = s.bc || 0; b.isCluckFury = !!s.cf;
    }
    function applyGuestInput(boxer, inp) {
      if (!inp) return;
      boxer.blocking = false;
      if (inp.left) boxer.move(-1);
      if (inp.right) boxer.move(1);
      if (inp.block) {
        boxer.blocking = true;
        if (!boxer._blockStarted) { boxer.blockStartTime = performance.now(); boxer._blockStarted = true; }
      } else { boxer._blockStarted = false; }
      boxer.aimY = inp.aimY || 0;
      // Process one-shot actions via counters
      if (inp.ac) {
        if (inp.ac.jump > lastHostActionCounts.jump) boxer.jump();
        if (inp.ac.jab > lastHostActionCounts.jab) boxer.punch('jab');
        if (inp.ac.cross > lastHostActionCounts.cross) boxer.punch('cross');
        if (inp.ac.hook > lastHostActionCounts.hook) boxer.punch('hook');
        if (inp.ac.upper > lastHostActionCounts.upper) boxer.punch('uppercut');
        if (inp.ac.body > lastHostActionCounts.body) boxer.punch('bodyshot');
        if (inp.ac.ability > lastHostActionCounts.ability) {
          if (boxer.name === 'CHESTER' && boxer.abilityCharge >= 100) {
            boxer.isCluckFury = true; boxer.cluckFuryTimer = 8; boxer.abilityCharge = 0;
            spawnFloatingText(boxer.x, boxer.headY - 40, 'CLUCK FURY!', '#fff700');
          }
        }
        lastHostActionCounts = Object.assign({}, inp.ac);
      }
    }

    // ── Button Wiring ──
    document.getElementById('btn-vs-cpu').addEventListener('click', () => {
      document.getElementById('party-overlay').style.display = 'none';
      showPartyMenu = false; isOnlineMode = false;
      gameState = 'CHARSELECT';
    });

    function isCharLocked(ch) {
      if (!ch.authorizedEmails) return false;
      const user = localStorage.getItem('knockout_user');
      if (!user) return true; // Guests can't access restricted characters
      return !ch.authorizedEmails.includes(user.toLowerCase());
    }

    // Character select click handling
    canvas.addEventListener('click', (e) => {
      if (gameState !== 'CHARSELECT') return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width, scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      // Adjust mx for scroll
      const scrollAdjustedMx = mx + charSelectScroll;

      // Check card clicks
      const cardW = 180, cardH = 280, gap = 15;
      const totalW = CHARACTERS.length * cardW + (CHARACTERS.length - 1) * gap;
      const startX = (W - totalW) / 2;
      const drawStartX = totalW > W - 80 ? 40 : startX;

      for (let i = 0; i < CHARACTERS.length; i++) {
        const cx = drawStartX + i * (cardW + gap), cy = 55;
        if (scrollAdjustedMx >= cx && scrollAdjustedMx <= cx + cardW && my >= cy && my <= cy + cardH) {
          if (isCharLocked(CHARACTERS[i])) {
            triggerShake(5, 300); // Visual feedback that it's locked
            spawnFloatingText(mx, my, 'LOCKED', '#ff4444');
            return;
          }
          selectedCharIdx = i;
          if (isOnlineMode) {
            PM.playerReady = false;
            if (PM.conn && PM.conn.open) {
              PM.conn.send({ type: 'char_update', idx: i });
              PM.conn.send({ type: 'ready', ready: false });
            }
          }
        }
      }

      // Check start button click (not affected by scroll)
      if (charSelectBtnRegion) {
        const b = charSelectBtnRegion;
        if (mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h) {
          if (isOnlineMode) {
            PM.playerReady = !PM.playerReady;
            if (PM.conn && PM.conn.open) {
              PM.conn.send({ type: 'ready', ready: PM.playerReady });
            }
            if (PM.playerReady && PM.enemyReady) startGame();
          } else {
            startGame();
          }
        }
      }
      // Check test mode button click
      if (charSelectTestBtnRegion && !isCharLocked(CHARACTERS[selectedCharIdx])) {
        const tb = charSelectTestBtnRegion;
        if (mx >= tb.x && mx <= tb.x + tb.w && my >= tb.y && my <= tb.y + tb.h) {
          startTestMode();
        }
      }
    });

    // Hover tracking for char select
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width, scaleY = H / rect.height;
      const mx = (e.clientX - rect.left) * scaleX;
      const my = (e.clientY - rect.top) * scaleY;

      if (gameState === 'CHARSELECT') {
        const scrollAdjustedMx = mx + charSelectScroll;
        charHoverIdx = -1;
        const cardW = 180, cardH = 280, gap = 15;
        const totalW = CHARACTERS.length * cardW + (CHARACTERS.length - 1) * gap;
        const startX = (W - totalW) / 2;
        const drawStartX = totalW > W - 80 ? 40 : startX;

        for (let i = 0; i < CHARACTERS.length; i++) {
          const cx = drawStartX + i * (cardW + gap), cy = 55;
          if (scrollAdjustedMx >= cx && scrollAdjustedMx <= cx + cardW && my >= cy && my <= cy + cardH) {
            charHoverIdx = i;
          }
        }

        // Drag scrolling logic
        if (charSelectDragging) {
          const dx = mx - charSelectLastX;
          charSelectTargetScroll -= dx;
          charSelectScroll -= dx; // Immediate feedback
          charSelectLastX = mx;
        }
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      if (gameState !== 'CHARSELECT') return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      const mx = (e.clientX - rect.left) * scaleX;
      charSelectDragging = true;
      charSelectLastX = mx;
    });

    window.addEventListener('mouseup', () => {
      charSelectDragging = false;
    });

    canvas.addEventListener('wheel', (e) => {
      if (gameState !== 'CHARSELECT') return;
      charSelectTargetScroll += e.deltaY;
      e.preventDefault();
    }, { passive: false });

    // Space to start from charselect
    window.addEventListener('keydown', (e) => {
      if (e.target.closest('input, textarea')) return;
      if (gameState === 'CHARSELECT' && e.code === 'Space') {
        if (isOnlineMode) {
          PM.playerReady = !PM.playerReady;
          if (PM.conn && PM.conn.open) {
            PM.conn.send({ type: 'ready', ready: PM.playerReady });
          }
          if (PM.playerReady && PM.enemyReady) startGame();
        } else {
          startGame();
        }
        e.preventDefault();
      }

      // Double-tap J → Test Mode (Chester only)
      if (gameState === 'CHARSELECT' && e.code === 'KeyJ') {
        const ch = CHARACTERS[selectedCharIdx];
        if (ch && ch.name === 'CHESTER' && !isCharLocked(ch) && !isOnlineMode) {
          if (!window._lastJTap) window._lastJTap = 0;
          const now = performance.now();
          if (now - window._lastJTap < 400) {
            startTestMode();
            window._lastJTap = 0;
          } else {
            window._lastJTap = now;
          }
        }
      }

      // Ability Activation (Q)
      if (gameState === 'FIGHTING' && e.code === 'KeyQ' && player.name === 'CHESTER' && player.abilityCharge >= 100 && !player.isCluckFury && !cutsceneActive) {
        // Trigger Cinematic Cutscene
        cutsceneActive = true;
        cutsceneTimer = 1.5;
        cutsceneBoxer = player;
        cameraTargetX = player.x;
        cameraTargetY = player.y - 40;

        player.isCluckFury = true;
        player.cluckFuryTimer = 8;
        player.abilityCharge = 0;
        spawnFloatingText(player.x, player.headY - 40, 'CLUCK FURY!', '#fff700');
        boostCrowdExcitement(0.5);
        if (isOnlineMode) PM.sendInput({ type: 'ability_activation' });
      } else if (gameState === 'FIGHTING' && e.code === 'KeyQ') {
        player.punch('bodyshot');
        if (isOnlineMode) PM.sendInput({ type: 'bodyshot' });
      }
    });
    document.getElementById('btn-make-party').addEventListener('click', async () => {
      const pw = document.getElementById('party-password').value;
      setStatus('');
      const ok = await PM.createParty(pw);
      if (ok) {
        document.getElementById('party-menu').style.display = 'none';
        document.getElementById('waiting-screen').style.display = 'block';
        document.getElementById('waiting-code').textContent = 'ROOM: ' + pw.trim().toUpperCase();
      }
    });
    document.getElementById('btn-join-party').addEventListener('click', async () => {
      const pw = document.getElementById('party-password').value;
      setStatus('');
      await PM.joinParty(pw);
    });
    document.getElementById('btn-cancel-party').addEventListener('click', () => {
      PM.leave();
      document.getElementById('waiting-screen').style.display = 'none';
      document.getElementById('party-menu').style.display = 'flex';
      showPartyMenu = true;
    });
    document.getElementById('btn-dc-ok').addEventListener('click', () => {
      document.getElementById('disconnect-msg').style.display = 'none';
      PM.leave(); showPartyMenu = false; gameState = 'TITLE';
    });
    // Prevent game keys while typing room code
    // (Handled by global listener tag check now)

    // Guest key tracking for one-shot actions
    window.addEventListener('keydown', e => {
      if (e.target.closest('input, textarea')) return;
      if (!isOnlineMode || PM.isHost) return;
      const map = { KeyE: 'cross', KeyR: 'hook', KeyF: 'upper', Space: 'jump' };
      if (map[e.code]) { guestActionCounts[map[e.code]]++; }
      if (e.code === 'KeyQ') {
        if (player.name === 'CHESTER' && player.abilityCharge >= 100) guestActionCounts.ability++;
        else guestActionCounts.body++;
      }
    });
    // LMB jab counter for guest
    canvas.addEventListener('mousedown', e => {
      if (!isOnlineMode || PM.isHost) return;
      if (e.button === 0) guestActionCounts.jab++;
    });

    // ── Start ──
    PM.init();
    resetFighters();
    requestAnimationFrame(gameLoop);

    // ── Exclusive Content Redemption ──
    const redeemEmailInput = document.getElementById('redeem-email');
    const btnRedeem = document.getElementById('btn-redeem');
    const partyStatus = document.getElementById('party-status');

    // Stop propagation so typing in redeem box doesn't trigger game keys
    redeemEmailInput.addEventListener('keydown', e => e.stopPropagation());
    redeemEmailInput.addEventListener('keyup', e => e.stopPropagation());

    btnRedeem.addEventListener('click', () => {
      const email = redeemEmailInput.value.trim().toLowerCase();
      if (!email) {
        partyStatus.style.color = '#ff4444';
        partyStatus.textContent = 'ENTER AN EMAIL';
        return;
      }
      if (!email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
        partyStatus.style.color = '#ff4444';
        partyStatus.textContent = 'INVALID EMAIL FORMAT';
        return;
      }

      // Check if email is authorized for Chester (index 5)
      const chester = CHARACTERS[5];
      if (chester && chester.authorizedEmails) {
        if (!chester.authorizedEmails.includes(email)) {
          partyStatus.style.color = '#ff4444';
          partyStatus.textContent = 'NOT CORRECT';
          return;
        }
      }

      // Save as the current user
      localStorage.setItem('knockout_user', email);
      partyStatus.style.color = '#44ff44';
      partyStatus.textContent = 'SUCCESS! CONTENT UNLOCKED';

      // Visual feedback: clear input
      redeemEmailInput.value = '';

      setTimeout(() => {
        partyStatus.style.color = '#ff4444';
        partyStatus.textContent = '';
      }, 3000);
    });


  </script>
</body>

</html>